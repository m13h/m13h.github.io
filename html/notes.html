<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-10-14 to. 00:49 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes from CTF tasks (math/programming-related)</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script type="text/javascript" src="styles/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="styles/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<style>pre.src{background:#1f1f10;color:white;} .footref{font-size: 100%;} html,p{font-size: 115%;}</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Notes from CTF tasks (math/programming-related)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga284376">About</a></li>
<li><a href="#orge71fea0">N1CTF2020</a>
<ul>
<li><a href="#org5470057">General Comments</a></li>
<li><a href="#orgfc32c82">crypto:VSS</a></li>
<li><a href="#org93b5404">crypto:FlagBot</a></li>
<li><a href="#org42a0a72">crypto:curve</a></li>
<li><a href="#orgc2b78a8">crypto:easy RSA?</a></li>
<li><a href="#org84d6f43">crypto:babyProof</a></li>
</ul>
</li>
<li><a href="#orgf1b5cff">Hack.lu 2020</a>
<ul>
<li><a href="#orgb0e0b77">General Comments</a></li>
<li><a href="#org8bbb614">crypto:Bad Primes</a></li>
<li><a href="#org60c3fed">misc:BabyJS</a></li>
<li><a href="#orgb215406">crypto:Conquering Premium Access</a></li>
<li><a href="#orgad3095f">misc:P*rn Protocol</a></li>
<li><a href="#orgbb3f2f6">crypto:Pwnhub Collection</a></li>
</ul>
</li>
<li><a href="#org5a7ad4c">CyberSecurityRumble 2020</a>
<ul>
<li><a href="#org5e06ebf">General Comments</a></li>
<li><a href="#orgf594885">crypto:Pady McPadface</a></li>
<li><a href="#org41b0ca4">crypto:dlog</a></li>
<li><a href="#orgc28e707">crypto:ezdsa</a></li>
<li><a href="#orgba51800">misc:Pylindrome</a></li>
<li><a href="#org25e6339">baby:Hashfun</a></li>
<li><a href="#orgef031ac">crypto:dtls</a></li>
<li><a href="#org15dd5d4">web:Yanote</a></li>
</ul>
</li>
<li><a href="#org2e1cfdb">BalsnCTF 2020</a>
<ul>
<li><a href="#balsn2020">General Comments</a></li>
<li><a href="#orgb56f0da">Happy Farm</a>
<ul>
<li><a href="#org6cd3b2f">Task 1: AES CBC</a></li>
<li><a href="#org488a58c">Task 2: RSA and Euler hacks</a></li>
<li><a href="#org23d1623">Task 3: Borked RCA</a></li>
</ul>
</li>
<li><a href="#orgc53e099">The Last Bitcoin</a></li>
<li><a href="#orge876fdd">The Danger of Google&rsquo;s Omnipotence</a></li>
<li><a href="#orgbacc28c">aeshash &amp; IEAIE &amp; Patience I</a></li>
<li><a href="#orgb6b0708">babyrev</a></li>
</ul>
</li>
<li><a href="#org18e99b7">DragonCTF 2020</a>
<ul>
<li><a href="#dragon2020">General Comments</a></li>
<li><a href="#org73ae512">Frying in motion</a></li>
<li><a href="#org2ae8c68">Bit Flip 1</a></li>
<li><a href="#orgda931ae">babykok</a></li>
<li><a href="#orgf5a413f">Bit Flip 2 &amp; 3</a></li>
</ul>
</li>
<li><a href="#orgb22615c">HITCON &amp; perfectblue</a></li>
<li><a href="#org7c4477e">ASIS 2020</a>
<ul>
<li><a href="#asis2020">General Comments</a></li>
<li><a href="#org45269d6">Chloe</a></li>
<li><a href="#orgb03e139">Coffeehouse (cafe house)</a></li>
<li><a href="#orgac1e4c4">congruence</a></li>
<li><a href="#orged5f8cc">Trio couleurs</a></li>
<li><a href="#org686b3ce">Baby MD5</a></li>
<li><a href="#org1d0da57">גל התקפה (Attack Wave)</a></li>
<li><a href="#orge325775">Election &amp; Galiver</a></li>
</ul>
</li>
<li><a href="#orgb33efe6">JustCTF 2020</a>
<ul>
<li><a href="#justctf2020">General Comments</a></li>
<li><a href="#orgb61a1d9">25519</a></li>
<li><a href="#org6f65768">Oracles</a></li>
<li><a href="#org0efb280">That&rsquo;s not crypto</a></li>
<li><a href="#org6e67f8a">PDF is broken, and so is this file</a></li>
</ul>
</li>
<li><a href="#org5bba4e8">zer0pts CTF 2021</a>
<ul>
<li><a href="#zer0pts2021">General Comments</a></li>
<li><a href="#org26afe66">Easy Pseudo Random</a></li>
<li><a href="#orge58a3f6">wa(rsa)mup</a></li>
<li><a href="#orgcabd6e6">janken vs. yoshiking</a></li>
<li><a href="#orgd6f81aa">ot or not ot</a></li>
<li><a href="#orgaefc0d3">Triple AES</a></li>
<li><a href="#orga412e49">Kantan Calc</a></li>
</ul>
</li>
<li><a href="#org3f89bf9">Misc/Zh3r0 2021</a>
<ul>
<li><a href="#misc2021">General Comments</a></li>
<li><a href="#orga613d87">Boring MT blah (Zh3r0)</a></li>
<li><a href="#org46eff17">A<sub>52</sub> group (unknown CTF)</a></li>
<li><a href="#org1bd91cd">Unicode troll (unknown CTF)</a></li>
<li><a href="#orgae4e9c0">homebrew hash function (Zh3r0)</a></li>
<li><a href="#orgd8145e1">almost-combinadics (Zh3r0)</a></li>
<li><a href="#org22b8ceb">approximate mastermind (Zh3r0)</a></li>
</ul>
</li>
<li><a href="#org38f8333">perfectblue CTF 2021</a>
<ul>
<li><a href="#pbctf2021">General Comments</a></li>
<li><a href="#org23dea4e">Alkaloid Stream</a></li>
<li><a href="#org1f962ff">Steroid Stream</a></li>
<li><a href="#org63210ee">GoodHash</a></li>
<li><a href="#org100ea52">Seed Me</a></li>
<li><a href="#orgecaebf2">Yet Another PRNG</a></li>
<li><a href="#orgb67f4f9">Yet Another RSA</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga284376" class="outline-2">
<h2 id="orga284376">About</h2>
<div class="outline-text-2" id="text-orga284376">
<p>
<b>Who:</b> <code>tope</code> of <code>mode13h</code> (two-man team from Norway)
</p>

<p>
<b>Contact:</b> <code>tope#9134@Discord</code> (I am friendly to the point of being flirtatious,
so feel free to message me)
</p>

<p>
<b>Audience:</b> I am writing these notes to some imagined fellow CTFer who looked at
the same tasks that I did, but missed some critical step for the solve, or
perhaps someone who did solve them and just wants to compare notes. I&rsquo;ll rarely
re-post the full problem as given in the CTF, nor do very detailed expositions.
For the time being this isn&rsquo;t intended as a pedagogical resource. The target
audience (&ldquo;you&rdquo;) are not complete beginners, <i>some</i> facility with math is
assumed.
</p>

<p>
<b>Content:</b> My favorite tasks are of the &ldquo;puzzle&rdquo;<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> variety. In CTFs these
would normally be found under misc and crypto. My safe space is the intersection
between programming and mathematics.
</p>

<p>
<b>Motivation:</b> I am fascinated by the generalities behind puzzles&#x2013;i.e. their
mathematical expression&#x2013;and I love solving problems with programming.
Fascination gives off a glow, and this glow-energy is what I&rsquo;d like to call
motivation. The competitive element of CTFs has little bearing, and I tend to
avoid CTFs with uninteresting problems.
</p>
</div>
</div>

<div id="outline-container-orge71fea0" class="outline-2">
<h2 id="orge71fea0">N1CTF2020</h2>
<div class="outline-text-2" id="text-orge71fea0">
</div>
<div id="outline-container-org5470057" class="outline-3">
<h3 id="org5470057">General Comments</h3>
<div class="outline-text-3" id="text-org5470057">
<p>
An <b>A+</b> CTF! An <i>incredible</i> amount of tasks, from mid-tier to top-tier
difficulty level. Objectively the task set alone deserves a ~100 rating on
CTFTime<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>.
</p>

<p>
I did the crypto tasks and will outline solves for those below. I also glanced at some of the
&ldquo;easier&rdquo; tasks in misc and web, but even the entry-level tasks in those
categories were beyond me.
</p>

<p>
<i>Personal downside #1</i>: very biased toward web, rev, and pwn, which I am pretty
clueless about, though those are the &ldquo;true&rdquo; staples of CTF. I realize this is
more like a pure upside for most people.
</p>

<p>
On the end of the first day there were only three crypto tasks released yet more
than fifteen(!?) web, pwn, and rev tasks out. I sat around twiddling my thumbs a
bit, feeling pretty useless.
</p>

<p>
The only misc-like task I saw involved PHP, which is more of a mental plague
than a programming language<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>. I played around with it a bit, but finally
just went to bed feeling a little bit dumber and somewhat frustrated because I
thought all tasks had been released and that I&rsquo;d be useless for the rest of the
CTF.
</p>

<p>
<i>Personal downside #2</i>: Two more crypto were released just after I&rsquo;d gone to
sleep on day two, so I only had a few hours for them when I woke up. Although
the new tasks were a nice surprise, the timing was very unfortunate for me.
</p>

<p>
<i>Plea for organizers in general: please consider having all tasks out by the
mid-way point of the CTF.</i> If not, then communicate your planned task release
schedule so it&rsquo;s possible to better manage our time?
</p>

<p>
We ended up placing 13th<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>.
</p>
</div>
</div>

<div id="outline-container-orgfc32c82" class="outline-3">
<h3 id="orgfc32c82">crypto:VSS</h3>
<div class="outline-text-3" id="text-orgfc32c82">
<p>
You&rsquo;re given some code which generates a QR-code image of the flag and uses that
image to create two new randomized images which&#x2013;when combined&#x2013;would
reconstruct the original (albeit transposed? I am guessing, I didn&rsquo;t actually
run the code). You also receive <i>one</i> of the images generated. It struck me as a
little cryptic.
</p>

<p>
I ignored the whole visual threshold part of the task and noted it uses Python&rsquo;s
random module to generate the pixels in the output images. That&rsquo;s a lot of
random data, and the QR-code image it&rsquo;s based on has a lot of known fixed
output. After double-checking that the QR-image had enough known pixels (you get
to reverse one bit of state per pixel) and where it was (it would be hell if it
wasn&rsquo;t contiguous), it reduces to a &ldquo;standard&rdquo; reverse-the-RNG-state task.
</p>

<p>
For the reversing Python&rsquo;s MT the <i>easy</i> way you need \(32 \cdot 672\) contiguous
bits of output. That is if you don&rsquo;t have to worry about missing state. You need
to undo the tempering that MT does to its output words:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #51afef;">def</span> <span style="color: #c678dd;">untemper</span>(x):
   <span style="color: #dcaeea;">x</span> ^= (x &gt;&gt; <span style="color: #da8548; font-weight: bold;">18</span>)
   <span style="color: #dcaeea;">x</span> ^= (x &lt;&lt; <span style="color: #da8548; font-weight: bold;">15</span>) &amp; 0xefc60000
   <span style="color: #dcaeea;">x</span> ^= ((x &lt;&lt; <span style="color: #da8548; font-weight: bold;">7</span>) &amp; 0x9d2c5680) ^ ((x &lt;&lt; <span style="color: #da8548; font-weight: bold;">14</span>) &amp; 0x94284000) ^ ((x &lt;&lt; <span style="color: #da8548; font-weight: bold;">21</span>) &amp; 0x14200000) ^ ((x &lt;&lt; <span style="color: #da8548; font-weight: bold;">28</span>) &amp; 0x10000000)
   <span style="color: #dcaeea;">x</span> ^= (x &gt;&gt; <span style="color: #da8548; font-weight: bold;">11</span>) ^ (x &gt;&gt; <span style="color: #da8548; font-weight: bold;">22</span>)
   <span style="color: #51afef;">return</span> x
</pre>
</div>

<p>
You combine words <code>i</code>, <code>i+1</code>, and <code>i+M</code> to get word <code>i+N</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #dcaeea;">tmp</span> = w[i][<span style="color: #da8548; font-weight: bold;">31</span>] ^ w[i+<span style="color: #da8548; font-weight: bold;">1</span>][:<span style="color: #da8548; font-weight: bold;">31</span>]  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">using slice notation to select bits</span>
 <span style="color: #dcaeea;">w</span>[i+N] = tmp&gt;&gt;<span style="color: #da8548; font-weight: bold;">1</span> ^ w[i+M] ^ (A <span style="color: #51afef;">if</span> tmp[<span style="color: #da8548; font-weight: bold;">0</span>] <span style="color: #51afef;">else</span> <span style="color: #da8548; font-weight: bold;">0</span>)
</pre>
</div>

<p>
<code>M</code>, <code>N</code>, <code>A</code> are constants from <code>_randommodule.c</code> in CPython source code. Then
you reapply the tempering (see aforementioned <code>.c</code> source) and it should match
Python&rsquo;s output. That&rsquo;s the basic idea.
</p>

<p>
It was a task which is very easy to realize the solution but rather painful to
implement. I struggled with infinite little indexing bugs. The headache I got
from trying to directly indexing into <code>bin(random.getrandbits(...))</code> was not
worth it. (Bits within words run from bit \(2^{31}\) to \(1\), but the words are in
little-endian order.) I even had bugs in the final solution as some randomness
was leaking through, but fortunately QR-codes are highly redundant, so I didn&rsquo;t
care. Then again I probably did things needlessly complicated by
reverse-generating the original QR-code instead of simply generating the
&ldquo;companion&rdquo; image to the one shared.
</p>

<p>
Apart from headaches it gave me with my own bugs, it&rsquo;s actually a fairly clever
task, because there aren&rsquo;t any obvious &ldquo;hints&rdquo; that points you in the right
direction, so it might take a while to notice. I was pretty lucky.
</p>
</div>
</div>

<div id="outline-container-org93b5404" class="outline-3">
<h3 id="org93b5404">crypto:FlagBot</h3>
<div class="outline-text-3" id="text-org93b5404">
<p>
Several random 256-bit elliptic curves are generated and used to do a standard
key exchange to AES-encrypt the flag. The curves are all asserted to be
non-smooth and resistant to MOV attack. You get the public output of the
exchanges as well as the encrypted messages. It&rsquo;s a very nice and clean task
with a likewise straightforward implementation. It was a pure blessing after the
indexical spaghetti that was VSS.
</p>

<p>
The key to realize is that the secret is reused (for both client and server).
The generated random curves have a lot of small random subgroups, so you can
solve the discrete log in those subgroups (multiply the generator and public
keys by \((p-1)/q\) to put it in the subgroup of size \(q\)), get constraints like
\(secret = x_i \pmod{q_i}\), and then do Chinese Remainder when you have enough. A
partial Pohlig-Hellman, if you will.
</p>

<p>
I think I did most of this task in REPL, but the pseudo-code sketch would be:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #dcaeea;">crt_r</span>, <span style="color: #dcaeea;">crt_s</span> = [], []
 <span style="color: #51afef;">for</span> ec,pk_r,pk_s <span style="color: #51afef;">in</span> data:
   <span style="color: #dcaeea;">order</span> = ec.order()
   <span style="color: #51afef;">for</span> f <span style="color: #51afef;">in</span> small_factors(order):
     crt_r.append( (babystepgiantstep(f, pk_r*(order/f), g*(order/f)), f) )
     crt_s.append( (babystepgiantstep(f, pk_s*(order/f), g*(order/f)), f) )

 <span style="color: #dcaeea;">r</span>,<span style="color: #dcaeea;">s</span> = crt(*crt_r)[<span style="color: #da8548; font-weight: bold;">0</span>], crt(*crt_s)[<span style="color: #da8548; font-weight: bold;">0</span>]
</pre>
</div>
</div>
</div>

<div id="outline-container-org42a0a72" class="outline-3">
<h3 id="org42a0a72">crypto:curve</h3>
<div class="outline-text-3" id="text-org42a0a72">
<p>
In this task (against a live server) you&rsquo;re asked for elliptic curve parameters
\((p, a, b)\) and two points \((G_1, G_2)\) and then have to solve 30 rounds of
distinguishing \(G_1 \cdot r \cdot s\) from \(G_1 \cdot x\) when given \(G_1 \cdot r\)
and \(G_2 \cdot s\) (for random secret integers \(r, s, x\)). It will throw an
exception if you give it a singular curve or points not on the curve.
</p>

<p>
At first glance I thought this was too similar to <code>FlagBot</code>, because there are
no checks against the points being in a small subgroup. I knew you could also
use trace 1 curves on which the much-copy-pasted Smart attack works, but I only
have that code in some Sage docker; I wanted to use my own comfortable code and
homemade Python libraries. Besides, <i>I got this</i>: I thought it would just be a
matter of trivially putting them into small subgroups and solving the CRT again.
A bit too easy, maybe&#x2026;
</p>

<p>
Yeah, after a while I realized my oops: it required a very <i>large</i> prime modulus
\(p\) and calls <code>E.order()</code> on the curve &#x2013; <i>and</i> there&rsquo;s a timer on the program.
The <code>E.order()</code> call takes well over a minute, sometimes several minutes, and so
there&rsquo;s no time to do the loop. I wasted some time trying to find random curves for
which <code>E.order()</code> was smooth or took less time but&#x2026;
</p>

<p>
Finally I relented and tested <code>E.order()</code> on a curve with \(|E_p| = p\). It was
instant, of course, so&#x2026; <i>sigh</i> Copy-pasted Sage code it is, then.
</p>

<p>
Now the problem was to generate curves with trace 1, which I didn&rsquo;t know how to
do, but <code>poiko</code> talked of a DEFCON task which had involved generating such
curves and gave me a paper: <a href="http://www.monnerat.info/publications/anomalous.pdf">http://www.monnerat.info/publications/anomalous.pdf</a>
</p>

<p>
From the paper I figured I wanted curves under primes \(p = 11 m (m+1) + 3\) with
\((a,b)\) which gives j-invariant equal to \(-2^{15}\), I quickly found plenty such
curves. Then copy-paste <code>Smart_Attack()</code> and blah, blah, the usual stuff. (I
really despise copy-pasting.) A bit unrewarding due to my stubbornness, but I
have to admit it was a good task in the end, even if the &ldquo;hidden&rdquo; constraint of
&ldquo;the given curve must also have a fast <code>E.order()</code>&rdquo; was a bit devious<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>.
</p>
</div>
</div>

<div id="outline-container-orgc2b78a8" class="outline-3">
<h3 id="orgc2b78a8">crypto:easy RSA?</h3>
<div class="outline-text-3" id="text-orgc2b78a8">
<p>
A fun task which had two stages.
</p>

<p>
It generates some RSA-modulus \(n = p*q\) and encrypts a large vector with lots of
numbers. These numbers are the vector (dot) products between the flag and random
numbers, offset by some small error, and then modulo a small prime. You are
given the random numbers used for free, but the errors are secret.
</p>

<p>
The primes are generated in a truly bizarre way:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #dcaeea;">mark</span> = <span style="color: #da8548; font-weight: bold;">3</span>**<span style="color: #da8548; font-weight: bold;">66</span>
 <span style="color: #51afef;">def</span> <span style="color: #c678dd;">get_random_prime</span>():
   <span style="color: #dcaeea;">total</span> = <span style="color: #da8548; font-weight: bold;">0</span>
   <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">5</span>):
     <span style="color: #dcaeea;">total</span> += mark**i * getRandomNBitInteger(<span style="color: #da8548; font-weight: bold;">32</span>)
   <span style="color: #dcaeea;">fac</span> = <span style="color: #c678dd;">str</span>(factor(total)).split(<span style="color: #98be65;">" * "</span>)
   <span style="color: #51afef;">return</span> <span style="color: #c678dd;">int</span>(fac[-<span style="color: #da8548; font-weight: bold;">1</span>])
</pre>
</div>

<p>
It generates a number that has &ldquo;small&rdquo; digits in base-\(3^{66}\) and returns the
largest prime in the factorization of this number. That&rsquo;s one of the oddest ways
to generate primes I&rsquo;ve seen.
</p>

<p>
But (the &ldquo;a-ha&rdquo; moment) it means that \(n\cdot x\) also has &ldquo;small&rdquo; digits in
base-\(3^{66}\) for some \(x\) which is itself also &ldquo;small&rdquo; (compared to \(n\)).
</p>

<p>
I used a lattice like
</p>

<div class="org-src-container">
<pre class="src src-python">    [   n * HH, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>],
    [   <span style="color: #da8548; font-weight: bold;">1</span> * HH, HL, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
    [B**<span style="color: #da8548; font-weight: bold;">1</span> * HH, <span style="color: #da8548; font-weight: bold;">0</span>, HL, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
    [B**<span style="color: #da8548; font-weight: bold;">2</span> * HH, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, HL, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
    [B**<span style="color: #da8548; font-weight: bold;">3</span> * HH, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, HL, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
    [B**<span style="color: #da8548; font-weight: bold;">4</span> * HH, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, HL, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
    [B**<span style="color: #da8548; font-weight: bold;">5</span> * HH, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, HL, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
    [B**<span style="color: #da8548; font-weight: bold;">6</span> * HH, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, HL, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
    [B**<span style="color: #da8548; font-weight: bold;">7</span> * HH, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, HL, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
    [B**<span style="color: #da8548; font-weight: bold;">8</span> * HH, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, HL, <span style="color: #da8548; font-weight: bold;">0</span>],
</pre>
</div>

<p>
to find \(x\). There might be better ways, but it worked. Now to factor. Trivially
you can find the first and last digits of the primes. There&rsquo;s probably some more
clever way to do the whole thing, but I just did the dumb thing and used the
base-\(B\) digits of \(n\cdot x\) as coefficients for a polynomial over \(\mathbb{Z}_p\)
for some large \(p\) and factored that. That gave me two numbers back (when
multiplied so the least/most significant digits match), each of which shared one
of the big primes with \(n\). This was all a bit rushed because it took me too
long to discover the &ldquo;trick&rdquo; of finding \(n \cdot x\) and I just did everything in
the REPL at this point, using my own utility libraries and NTL wrapper.
</p>

<p>
So now I had \(n = p \cdot q\) and could decrypt the vector to get a big system of linear
relations with &ldquo;small errors&rdquo; modulo some small prime. The lattice is life, the
lattice is love. Maybe there&rsquo;s a more clever way to solve this as well, but did
I mention I was a little pressed for time at this point? The system in its
entirely was too big for my poor, slow LLL, but a small random subset of
equations worked just fine (every equation involved the entire flag).
</p>
</div>
</div>

<div id="outline-container-org84d6f43" class="outline-3">
<h3 id="org84d6f43">crypto:babyProof</h3>
<div class="outline-text-3" id="text-org84d6f43">
<p>
I &ldquo;solved&rdquo; this task but was a little too late. I had already realized the
solution by the last hour or two, but underestimated how many datasets I needed
and wasted some time with self-doubt, double-checking, and massaging
uncooperative lattices. When the competition ended I went to eat and by the time
I got back there was enough data and I got the (bittersweet) flag easily.
</p>

<p>
Like <code>FlagBot</code> it&rsquo;s a deceptively clean and simple task, where you don&rsquo;t realize
the problem until that sweet &ldquo;a-ha!&rdquo; moment. The server uses generated DSA
constants (a (huge) prime \(p\), a generator \(g\) for a large prime (\(q\)) subgroup
of \(\mathbb{Z}_p\)) to prove that it knows \(x\) in \(y=g^x \pmod p\) by giving you
\(y\), \(t=y^v \pmod p\) (for some secret ephemeral key \(v\)) and \(r = v - c \cdot x
 \pmod q\) with \(c\) being a SHA256 constant the recepient can derive from \((g, y,
 t)\). It looks respectable and above the board at first glance&#x2026;
</p>

<p>
But basically you need to forget everything I just said and ignore the whole
business with \(p\) and discrete logs. With \(r\) you&rsquo;re given a system of
inequalities like \(c_i \cdot flag + r_i < flag \pmod{q_i}\), because the ephemeral
key is erroneously generated to be less than \(x\) which was asserted to be 247
bits in the code (while \(q\) is 256 bits), so each equation ought to reveal a
little bit more about \(x\). It is clearly another lattice problem.
</p>

<p>
I&rsquo;m not sure if there are any better or more clever ways to set up the lattice,
but what worked for me in the end was the most obvious and straightforward:
</p>

<div class="org-src-container">
<pre class="src src-python"> [[<span style="color: #da8548; font-weight: bold;">1</span>,     <span style="color: #da8548; font-weight: bold;">0</span>, c0, c1, ...,  cn],
  [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">2</span>^<span style="color: #da8548; font-weight: bold;">248</span>, r0, r2, ...,  rn],
  [<span style="color: #da8548; font-weight: bold;">0</span>,     <span style="color: #da8548; font-weight: bold;">0</span>, q0,  <span style="color: #da8548; font-weight: bold;">0</span>, ...,   <span style="color: #da8548; font-weight: bold;">0</span>]
  [<span style="color: #da8548; font-weight: bold;">0</span>,     <span style="color: #da8548; font-weight: bold;">0</span>,  <span style="color: #da8548; font-weight: bold;">0</span>, q1, ...,   <span style="color: #da8548; font-weight: bold;">0</span>]
  [<span style="color: #da8548; font-weight: bold;">0</span>,     <span style="color: #da8548; font-weight: bold;">0</span>,  <span style="color: #da8548; font-weight: bold;">0</span>,  <span style="color: #da8548; font-weight: bold;">0</span>, ...,  qn]]
</pre>
</div>

<p>
<code>b'n1ctf{S0me_kn0wl3dg3_is_leak3d}'</code> Since I can no longer enter it on the site,
I&rsquo;ll leave it here to be sad and alone. :(
</p>
</div>
</div>
</div>

<div id="outline-container-orgf1b5cff" class="outline-2">
<h2 id="orgf1b5cff">Hack.lu 2020</h2>
<div class="outline-text-2" id="text-orgf1b5cff">
</div>
<div id="outline-container-orgb0e0b77" class="outline-3">
<h3 id="orgb0e0b77">General Comments</h3>
<div class="outline-text-3" id="text-orgb0e0b77">
<p>
An unfortunate step down from last weekend&rsquo;s <a href="n1ctf2020.html">N1CTF2020</a> even though this one has
a much higher rating on <code>CTFTime</code>.
</p>

<p>
<b>DISCLAIMER:</b> I&rsquo;m judging with very biased goggles here; I&rsquo;m sure web/rev/pwn
were all kinds of excellent and top notch woo-hoo, but misc and crypto was very
disappointing and demotivating for this rating bracket and I tapped out early.
It felt too easy and/or uninspired and/or unoriginal.
</p>

<p>
I am also going to sound <i>incredibly</i> negative. It wasn&rsquo;t that bad, but it
definitely wasn&rsquo;t a 100-point CTF, and that&rsquo;s the stance I&rsquo;m critiquing from.
The tasks I looked at felt like they belonged in the 50-70 range.
</p>

<p>
<a href="#orgbb3f2f6">crypto:Pwnhub Collection</a> which was (unnecessarily) gated behind rev would probably be
my pick for &ldquo;best&rdquo; crypto-task, because it actively combines two related
techniques in a sensible way. <a href="#orgb215406">crypto:Conquering Premium Access</a> had a copy-pastable
solution through Google, which was not fun to discover. <a href="#org7db1011">crypto:Bad Primes</a> was somewhat
trivial<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup>. <a href="#org60c3fed">misc:BabyJS</a> was cute but that&rsquo;s about it. More info about them
below. (As usual I will just outline the solves, these are just notes that should allow
anyone who attempted or failed the problems to solve them.)
</p>
</div>
</div>

<div id="outline-container-org8bbb614" class="outline-3">
<h3 id="org8bbb614"><a id="org7db1011"></a>crypto:Bad Primes<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup></h3>
<div class="outline-text-3" id="text-org8bbb614">
<p>
You&rsquo;re given \(c = flag^e \pmod{p\cdot q}\) with all numbers known except \(flag\).
The caveat is that \(e | p-1\) so there&rsquo;s no \(d = e^{-1} \pmod{p-1}\) for
recovering the flag directly. (Finding the flag \(\pmod q\) works trivially, so we
ignore that part.)
</p>

<p>
So finding the <i>e</i>-th root of \(c \pmod p\) is the interesting part. You can do it
in two different ways:
</p>

<p>
The I-don&rsquo;t-want-to-learn-anything Way (also known as
I&rsquo;m-a-professional-I-don&rsquo;t-have-time-for-this): press the <code>[Skip This Step]</code>
button and do <code>GF(p)(c).nth_root(e)</code> in Sage.
</p>

<p>
The Problem Child Way:
</p>

<p>
So we want a number \(x\) such that \(x^e = c \pmod p\) with \(p-1 = e\cdot s\) and
\(gcd(s,e) = 1\).
</p>

<p>
The a-ha comes after exploring the hunch that \(s\) is important here. Look at \(j
 = e^{-1} \pmod s\). This means means \(j\cdot e = 1 + k\cdot s\) for some \(k\). In
fact, it means that \(j\cdot e\cdot e = e + k\cdot (p-1)\). A-ha! So now \((c^j)^e
 = c^{e \cdot j} = c^{k\cdot s + 1} = x^{e\cdot (k\cdot s + 1)} = x^{k\cdot
 (p-1) + e} = x^e \pmod p\). Voila! \(c^j\) is a root.
</p>

<p>
Other reasoning lines probably exist too, but this was the one I took.
</p>

<p>
Next step we iteratively multiply with any <i>e</i>-th root of unity (= \(r^{(p-1)/e}\)
for any primitive element \(r\)) to cycle through the rest of the roots,
reconstructing the number in under mod \(p\cdot q\) with CRT to check if it is the
flag.
</p>
</div>
</div>

<div id="outline-container-org60c3fed" class="outline-3">
<h3 id="org60c3fed">misc:BabyJS</h3>
<div class="outline-text-3" id="text-org60c3fed">
<p>
A misc task that was misclassified as web(?). It&rsquo;s an exposition on the various ways
JavaScript tries very hard to be an awful programming language<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup>. It&rsquo;s
still not as awful as PHP, but we can&rsquo;t all be the champ.
</p>

<div class="org-src-container">
<pre class="src src-javascript"> is(a, <span style="color: #98be65;">'number'</span>);
 is(b, <span style="color: #98be65;">'number'</span>);
 assert(<span style="color: #98be65;">'1.1'</span>, a === b);
 assert(<span style="color: #98be65;">'1.2'</span>, <span style="color: #da8548; font-weight: bold;">1337</span> / a !== <span style="color: #da8548; font-weight: bold;">1337</span> / b);
</pre>
</div>

<p>
<code>[0.0, -0.0]</code> works because the division gives <code>[+Infinity, -Infinity]</code>. A
pimple, no big deal. Floats are tricky anyway.
</p>

<div class="org-src-container">
<pre class="src src-javascript"> isnt(c, <span style="color: #98be65;">'undefined'</span>);
 isnt(d, <span style="color: #98be65;">'undefined'</span>);
 <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">cast</span> = (f, ...a) =&gt; a.map(f);
 [c, d] = cast(Number, c, d);
 assert(<span style="color: #98be65;">'2.1'</span>, c !== d);
 [c, d] = cast(String, c, d);
 assert(<span style="color: #98be65;">'2.2'</span>, c === d);
</pre>
</div>

<p>
Probably a billion solutions here. I did <code>[{}, "[Object object]"]</code>. What&rsquo;s that
weird rash&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-javascript"> <span style="color: #51afef;">let</span> { e } = json;
 is(e, <span style="color: #98be65;">'number'</span>);
 <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">isCorrect</span> = e++&lt;e--&amp;&amp;!++e&lt;!--e&amp;&amp;--e&gt;e++;
 assert(<span style="color: #98be65;">'3'</span>, isCorrect);
</pre>
</div>

<p>
Up to boils now. Actual boils. <code>&lt;!--</code> is a comment. \(e=-1\) works.
</p>

<div class="org-src-container">
<pre class="src src-javascript"> <span style="color: #51afef;">const</span> { f } = json;
 isnt(f, <span style="color: #98be65;">'undefined'</span>);
 assert(<span style="color: #98be65;">'4'</span>, f == !f);
</pre>
</div>

<p>
<code>f=[]</code> works, I don&rsquo;t know why and I don&rsquo;t want to know. I fear that knowing
certain things actually make you less knowledgeable.
</p>

<div class="org-src-container">
<pre class="src src-javascript"> <span style="color: #51afef;">const</span> { g } = json;
 isnt(g, <span style="color: #98be65;">'undefined'</span>);
 <span style="color: #5B6268;">// </span><span style="color: #5B6268;">what you see:</span>
 <span style="color: #51afef;">function</span> <span style="color: #c678dd;">check</span>(<span style="color: #dcaeea;">x</span>) {
     <span style="color: #51afef;">return</span> {
         value: x * x
     };
 }
 <span style="color: #5B6268;">// </span><span style="color: #5B6268;">what the tokenizer sees:</span>
 <span style="color: #51afef;">function</span>
         check
              (
               x
                )
                 {
                  <span style="color: #51afef;">return</span>
                        {
                         value
                              :
                               x
                                *
                                 x
                                  }
                                   ;
                                    }
 assert(<span style="color: #98be65;">'5'</span>, g == check(g));
</pre>
</div>

<p>
This one was a little cute, like a magician&rsquo;s clever misdirection. The original
<code>check()</code> is replaced by this <code>check(x) { return; ... }</code> function. So <code>null</code>
works. Why does it return undefined? Haha!
<a href="https://news.ycombinator.com/item?id=3842713">https://news.ycombinator.com/item?id=3842713</a>
</p>

<p>
Blood-shot eyes, trichotillomania, psychosis.
</p>

<div class="org-src-container">
<pre class="src src-javascript"> <span style="color: #51afef;">const</span> { h } = json;
 is(h, <span style="color: #98be65;">'number'</span>);
 <span style="color: #51afef;">try</span> {
     JSON.parse(String(h));
     no(<span style="color: #98be65;">'6'</span>);
 } <span style="color: #51afef;">catch</span>(e){}
 passed(<span style="color: #98be65;">'6'</span>);
</pre>
</div>

<p>
Something like <code>1e1000</code> is converted to the string <code>"Infinity"</code>. Makes sense,
n&rsquo;est-ce pas?
</p>

<div class="org-src-container">
<pre class="src src-javascript"> <span style="color: #51afef;">const</span> { i } = json;
 isnt(i, <span style="color: #98be65;">'undefined'</span>);
 assert(<span style="color: #98be65;">'7'</span>, i <span style="color: #51afef;">in</span> [,,,...<span style="color: #98be65;">'"'</span>,,,Symbol.<span style="color: #51afef;">for</span>(<span style="color: #98be65;">"'"</span>),,,]);
</pre>
</div>

<p>
This unending dream. <code>3</code> is in the array because array index 3 is defined? I
don&rsquo;t know the logic. Any language which tries to pretend lists and maps are
somehow isomorphic data structures or algebras is insane. These languages were
invented by insane people.
</p>

<div class="org-src-container">
<pre class="src src-javascript"> <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">js</span> = eval(<span style="color: #98be65;">`(${clean})`</span>);
 assert(<span style="color: #98be65;">'8'</span>, Object.keys(json).length !== Object.keys(js).length);
</pre>
</div>

<p>
Put <code>__proto__</code> in the object and it will get hidden by the eval, because <code>:jazzhands-OO:</code>.
</p>

<div class="org-src-container">
<pre class="src src-javascript"> <span style="color: #51afef;">const</span> { y, z } = json;
 isnt(y, <span style="color: #98be65;">'undefined'</span>);
 isnt(z, <span style="color: #98be65;">'undefined'</span>);
 y[y][y](z)()(FLAG);
</pre>
</div>

<p>
When I looked over the task I figured I could pass all the other checks, but
this one seemed a bit need-to-actually-stop-and-think, &ldquo;huh?&rdquo; It had me puzzled
for a while, I don&rsquo;t really know JavaScript all that well. (I had to ask Google
if JavaScript has apply-overriding and stuff like that.) I also didn&rsquo;t realize
that <i>everything</i> has a <code>.constructor</code>. But eventually I discovered it just by
playing around in <code>nodejs</code> and from that a-ha the pieces fell into place.
</p>

<p>
<code>y = "constructor"</code> so <code>y[y]</code> becomes a function, i.e. <code>y.constructor</code>, and <code>y[y][y]</code> becomes the
function constructor, which takes its body as a string argument (?!) to be
eval&rsquo;d. So <code>z = "return console.log;"</code> for example.
</p>
</div>
</div>

<div id="outline-container-orgb215406" class="outline-3">
<h3 id="orgb215406">crypto:Conquering Premium Access</h3>
<div class="outline-text-3" id="text-orgb215406">
<p>
AES is used to encrypt the flag. You&rsquo;re handed the ciphertext and &ldquo;power traces&rdquo;
(voltage measurement?) of some hardware using AES to encrypt 10,000 known
16-byte plaintexts with the same key/IV as it did the flag.
</p>

<p>
The task hints about &ldquo;T-tables&rdquo;, &ldquo;aligned&rdquo; and that masking isn&rsquo;t employed. But
the task also said &ldquo;thank you to professor so-and-so for the data&rdquo; and links to
a university course, which is the biggest clue in my eyes. From that I figured
it&rsquo;s probably very &ldquo;textbook&rdquo; and intended to be solved with least effort.
</p>

<p>
So, textbook reading material:
<a href="https://www.tandfonline.com/doi/full/10.1080/23742917.2016.1231523">https://www.tandfonline.com/doi/full/10.1080/23742917.2016.1231523</a>
</p>

<p>
Indeed: almost disappointingly so. Finding a correlation based on the
1-bits-equals-more-power assumption turned out to work directly. You can ignore
the rounds, ignore the hints<sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup>, ignore everything, because there&rsquo;s so much
data and it&rsquo;s so artificially clean. Find the <code>key</code> (and <code>iv</code>) such that the
weight of <code>sbox[key^iv^plaintext]</code> has the highest correlation with (overall)
power consumption. <code>sbox[key^iv^plaintext]</code> is what the state gets set to in the
first round (in CBC mode), before <code>ShiftRows</code> etc. (Note that <code>ShiftRows</code>
doesn&rsquo;t change the weight.) Technically I ignored IV too because I simply forgot
about it, but that was fine too. You can simply use the full traces, and don&rsquo;t
have to target any point in time at all.
</p>

<p>
See also:
<a href="https://teamrocketist.github.io/2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/">https://teamrocketist.github.io/2018/11/14/Crypto-SquareCtf-2018-C4-leaky-power/</a>
which I also came across and seems to copy a lot of text/material from the above
link, but is a much more thorough write-up than anything I can produce.
</p>

<p>
Notice how it&rsquo;s also a verrrry similar problem? Yep: copy-pasting that code
should just work out of the box here too, though it is awful and slow so I ended
up rewriting it and doing most of my playing in REPL to pretend I wasn&rsquo;t a
fraud, trying to learn something in spite of everything.
</p>

<p>
And yeah, AES ECB to decrypt, so no IV was used, which I as stated implicitly
assumed. Can&rsquo;t recall if the task hinted to that or not, maybe it did?
</p>
</div>
</div>

<div id="outline-container-orgad3095f" class="outline-3">
<h3 id="orgad3095f">misc:P*rn Protocol</h3>
<div class="outline-text-3" id="text-orgad3095f">
<p>
A PDF described a very simple data protocol. Implement the protocol, request
login, log in with the given username and password, and get the flag.
</p>

<p>
Uhh?
</p>

<p>
This felt more like a &ldquo;socket programming for beginners&rdquo; tutorial than anything
else. Why was this even part of the task set?
</p>
</div>
</div>

<div id="outline-container-orgbb3f2f6" class="outline-3">
<h3 id="orgbb3f2f6">crypto:Pwnhub Collection</h3>
<div class="outline-text-3" id="text-orgbb3f2f6">
<p>
Labelled as hard crypto but really just easy-ish crypto gated behind ASAN rev.
<code>poiko</code> reversed it for me because I&rsquo;m a newbie, so can&rsquo;t really say much about
the rev part.
</p>

<p>
So from what <code>poiko</code> told me, the server does something roughly equivalent of
the following pseudocode:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #5B6268;"># </span><span style="color: #5B6268;">coll = list of pairs (category, link)</span>
 <span style="color: #dcaeea;">coll</span> = [t.strip().split(<span style="color: #98be65;">' '</span>) <span style="color: #51afef;">for</span> t <span style="color: #51afef;">in</span> <span style="color: #c678dd;">open</span>(<span style="color: #98be65;">'collection'</span>)]
 coll.append( (<span style="color: #c678dd;">input</span>(), <span style="color: #c678dd;">input</span>()) )

 <span style="color: #dcaeea;">txt</span> = <span style="color: #98be65;">' '</span>.join(x + <span style="color: #98be65;">'{'</span> + y + <span style="color: #98be65;">'}'</span> <span style="color: #51afef;">for</span> x,y <span style="color: #51afef;">in</span> <span style="color: #c678dd;">sorted</span>(coll, key=<span style="color: #51afef;">lambda</span> x:x[<span style="color: #da8548; font-weight: bold;">0</span>]))
 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">NB: sorted only on category element</span>

 <span style="color: #51afef;">print</span>(aes_cbc(fixed_key, fixed_iv, txt).hexdigest())
</pre>
</div>

<p>
So there&rsquo;s a string like <code>"blah{bleh} foo{bar} qux{crux}"</code> where we can add an
element that gets sorted in.
</p>

<p>
Finding the &ldquo;categories&rdquo; (the strings outside the curly braces) can be done very
efficiently with a binary search. Start with a string like <code>byte(127)*n</code> that
gets sorted last, observe the ciphertext output. Then for each byte keep a
<code>high,low</code> that you bisect and observe if we were flipped to another position in
the string (an earlier ciphertext block will change). This finds all the
categories very quickly.
</p>

<p>
They turned out to be <code>crypto flag misc</code> etc. (Which was something <code>poiko</code>
already guessed from doing the rev part, but I just double-checked.) Next step
is discovering the stuff inside the curly braces. Because I was being dumb, it
took me longer than it should have to realize it&rsquo;s the even-more-textbook method
of byte-by-byte brute forcing.
</p>

<p>
Input a category that gets sorted before <code>flag</code> with a long arbitrary link that
aligns things like so:
</p>

<pre class="example">
 # |---aes block---||---aes block---||---aes block---|
 # xxxx f{aaaaaaaaaaaaaaaaaaaa} flag{xxxxxxxxxxxxxxxxx
</pre>

<p>
Now pop off one <code>a</code> so the first <code>x</code> gets shifted in and note what that block
becomes in the output. Then discover the byte by cycling through and check the
output of encrypting with <code>link = "aaaa...aaaa} flag{" + b</code> for unknown byte
<code>b</code>. I.e. the string that&rsquo;s encrypted becomes:
</p>

<pre class="example">
 # |---aes block---||---aes block---||---aes block---|
 # xxxx f{aaaaaaaaaaaaaaaaaaa} flag{*} flag{xxxxxxxxxx
 # with '*' being the variable byte.
</pre>

<p>
Once there&rsquo;s a match you add the byte to what you know is there already (<code>"}
 flag{"</code>) and repeat for the next byte, until the entire link has been
discovered. Print it, ship it, done.
</p>
</div>
</div>
</div>


<div id="outline-container-org5a7ad4c" class="outline-2">
<h2 id="org5a7ad4c">CyberSecurityRumble 2020</h2>
<div class="outline-text-2" id="text-org5a7ad4c">
</div>
<div id="outline-container-org5e06ebf" class="outline-3">
<h3 id="org5e06ebf">General Comments</h3>
<div class="outline-text-3" id="text-org5e06ebf">
<p>
Overall a pretty good CTF. Decent number of tasks, variety, difficulty level and
so forth. The stuff I looked at seemed alright, though I got entangled in some
web business toward the end that soured things but that was my own fault.
</p>

<p>
We placed a cool 10th tho (much thanks to <code>poiko</code> spamming flags left and right
the last day).
</p>

<p>
There wasn&rsquo;t an <i>abundance</i> of crypto or mathematical misc tasks, but then I
don&rsquo;t really come to expect that much, it felt like there was <i>enough</i>. I kinda
think of crypto/math as the awkward little sister that&rsquo;s there only because the
organizers&rsquo; mother forced them to bring her along. The cool kids are talking
about real world stuff, hacking the Gibson, phreaking the phone lines, doing bug
bounties, whatever it is that real hackermen do, while she&rsquo;s just sitting there
arranging her fries to count out the Stirling numbers. Most of the time I&rsquo;m just
glad she&rsquo;s invited at all; if CTFs were to reflect real world industry, I
suspect it&rsquo;d be like 30 web-tasks and 2 revs.
</p>

<p>
I solved most of the easy crypto on the first evening, then did <a href="#orgef031ac">crypto:dtls</a> the
following morning, but the two remaining tasks were labelled web. Ugh. I looked
at the task named <code>blow</code> and just thought &ldquo;fuck no.&rdquo; Some kind of hellish
JWS/JWT JavaScript task they kept adding hints to because it got no
solves. From the hints alone I surmised that it has some trivial solution in
crypto terms, but it was probably a pain in the ass (aka the &ldquo;web&rdquo; part) to even
get started or progress to where it&rsquo;s relevant? So I worked on <a href="#org15dd5d4">web:Yanote</a>
instead, but failed that task miserably and eventually went off to nurse my
imposter syndrome in the corner.
</p>
</div>
</div>

<div id="outline-container-orgf594885" class="outline-3">
<h3 id="orgf594885">crypto:Pady McPadface</h3>
<div class="outline-text-3" id="text-orgf594885">
<p>
A live server that knows the flag traverses it bit by bit and gives \((r^2 +
bit)^e \pmod n\) for a fixed RSA modulus \(n\) using the standard \(e = 65537\). \(r\)
is an ephemeral random number a few bits than \(log_2 \sqrt{n}\) so \(r^2 < n\).
</p>

<p>
So basically I wanted to discover if the ciphertexts were quadratic residues or
not under the given (composite) modulus. I knew what to look up, and it turned
out to be pretty easy, but I was actually surprised to learn the Jacobi symbol
is easily calculable without knowing the factorization of \(n\). Huh! (It&rsquo;s also
surprising that this has never come up before.) I&rsquo;m glad to have learnt it, it
does seem like a neat trick.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">trailing_zeros</span>(a):
  <span style="color: #51afef;">return</span> (a ^ a - <span style="color: #da8548; font-weight: bold;">1</span>).bit_length() - <span style="color: #da8548; font-weight: bold;">1</span>

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">jacobi</span>(a,n):
  <span style="color: #51afef;">assert</span> n &amp; <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #5B6268;"># </span><span style="color: #5B6268;">n must be odd</span>
  <span style="color: #dcaeea;">sign</span> = <span style="color: #da8548; font-weight: bold;">1</span>

  <span style="color: #dcaeea;">a</span> = a % n
  <span style="color: #51afef;">while</span> a &gt; <span style="color: #da8548; font-weight: bold;">0</span>:
    <span style="color: #dcaeea;">r</span> = trailing_zeros(a)

    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">2 divides an odd number of times into a, then flip the sign if n is not</span>
    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">on the form 8k&#177;1</span>
    <span style="color: #51afef;">if</span> n % <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #51afef;">in</span> (<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">5</span>) <span style="color: #51afef;">and</span> r &amp; <span style="color: #da8548; font-weight: bold;">1</span>:
      <span style="color: #dcaeea;">sign</span> = -sign

    <span style="color: #dcaeea;">a</span>,<span style="color: #dcaeea;">n</span> = n, a &gt;&gt; r
    <span style="color: #51afef;">if</span> a % <span style="color: #da8548; font-weight: bold;">4</span> == <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #51afef;">and</span> n % <span style="color: #da8548; font-weight: bold;">4</span> == <span style="color: #da8548; font-weight: bold;">3</span>:
      <span style="color: #dcaeea;">sign</span> = -sign
    <span style="color: #dcaeea;">a</span> = a % n

  <span style="color: #51afef;">if</span> n != <span style="color: #da8548; font-weight: bold;">1</span>:
    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">a divides into n</span>
    <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>

  <span style="color: #51afef;">return</span> sign
</pre>
</div>

<p>
So then it was a matter of connecting to the server and getting several
ciphertext instances and calculating their Jacobi symbols
\(\left(\frac{c}{n}\right)\). If you find an instance where it is -1 then you know
the number is not a quadratic residue, so \(bit\) must be 1 in that position.
After some collected data you set the others to 0 and get the flag.
</p>
</div>
</div>

<div id="outline-container-org41b0ca4" class="outline-3">
<h3 id="org41b0ca4">crypto:dlog</h3>
<div class="outline-text-3" id="text-org41b0ca4">
<p>
The task implements some basic code for working with the secp256k1 elliptic
curve (\(y^2 = x^3 + 7\)). The ECC implementation is &ldquo;home-made&rdquo; with code mostly
taken from Wikipedia. It asks for a point, multiplies it with a random secret
number and asks you to recover this secret. No check is done on whether or not
the point you give is actually on the secp256k1 curve though, so it&rsquo;s a classic
invalid curve attack.
</p>

<p>
Basically you can set the \(b\) parameter in \(y^2 = x^3 + b\) to whatever you want.
(If you give the point \((s,t)\) it will use the curve \(y^2 = x^3 + (t^2-s^3)\).)
I&rsquo;ve solved some task before using a singular curve but couldn&rsquo;t remember how
the mapping worked off the top of my head and didn&rsquo;t find my old code for it, so
instead I idly looked for other \(b\) parameters where I could solve the discrete
log with Pohlig-Hellman as I had the tools for that more readily available. I
think there&rsquo;s 7 (?) different Frobenius traces among these curves, corresponding
to different orders of the resulting elliptic curve, but each had a very large
factor (133-135 bits) so this turned out to be a dead end.
</p>

<p>
I went back to pen and paper to see if I could manually work out the singular
mapping, partly as self-punishment for forgetting. Given one of the simplest
non-trivial points, \((1,1)\), the server will use the singular non-elliptic curve
\(y^2 = x^3\). The point-doubling formula then does the following: \(x \mapsto
\left(\frac{3x^2}{2y}\right)^2 - 2x = \frac{1}{4}x\) and similarly \(y \mapsto \frac{1}{8}y\).
Hm! That gave me the needed deja vu: indeed it seems that \(\frac{(n *
(1,1))_x}{(n * (1,1))_y} = n\), so it worked out nicely, and I didn&rsquo;t have to
wade through the full algebra. So yeah, just feed it <code>(1,1)</code> and then do \(\frac{x}{y}
\pmod p\) to get the secret.
</p>

<p>
It&rsquo;s probably supposed to be a pretty trivial task, but I made it overly
complicated by investigating all the curve-stuff.
</p>
</div>
</div>

<div id="outline-container-orgc28e707" class="outline-3">
<h3 id="orgc28e707">crypto:ezdsa</h3>
<div class="outline-text-3" id="text-orgc28e707">
<p>
A server is signing messages using the Python <code>ecdsa</code> library. I don&rsquo;t remember
the exact details but I think you were supposed to forge a signature.
Immediately there&rsquo;s was a glaring red flag with a <code>entropy=sony_rand</code> parameter
where <code>sony_rand</code> was a function that returned random bytes using Python&rsquo;s
<code>random</code> module. <code>ecdsa</code> uses this for generating the ephemeral \(k\) in its DSA
signature generation.
</p>

<p>
At first I thought this was going to be a very challenging task, because even
though the randomness of <code>getrandbits</code> isn&rsquo;t of cryptographic quality, it&rsquo;s very
hard to actually mirror it unless given at least some white (fully revealed)
output. I know it&rsquo;s seeded in Python from PID and two different clock functions,
so it might be bruteable, but it&rsquo;s hard to predict how far into the stream the
server is and so on and so forth; it seemed very daunting to brute all that. I
wondered if you could get startup time or restart the server, or maybe the
Mersenne Twister output had some cool linear relationship I wasn&rsquo;t aware of&#x2026;
</p>

<p>
I was just being dumb. I didn&rsquo;t notice it was a forking TCP server&#x2026; It will
clone the state and basically just re-use the same ephemeral \(k\) every single
time. This becomes immediately obvious when you set to actually collect some
signatures and see the \(r\) being repeated. I got pretty lucky that it was so
obvious once you start collecting data, if not it&rsquo;d be screwed.
</p>

<p>
So from two signatures \((r, \frac{H_1 + r x}{k})\) and \((r, \frac{H_2 + r x}{k})\)
where you can calculate the hashes \(H_1, H_2\), recovering the private multiplier
\(x\) is trivial and you can sign anything. I think I just set
<code>sk.privkey.secret_multiplier = x</code> and used <code>ecdsa</code> to do it in REPL.
</p>
</div>
</div>

<div id="outline-container-orgba51800" class="outline-3">
<h3 id="orgba51800">misc:Pylindrome</h3>
<div class="outline-text-3" id="text-orgba51800">
<p>
A server will run any Python code that&rsquo;s a valid palindrome (<code>x == x[::-1]</code>) in
a Python subprocess (of a user that can&rsquo;t read the flag file), but then <code>exec</code>
the <code>stdout</code> from that process (in the process that can read the flag file).
There&rsquo;s a limited attempt at preventing the task from becoming trivial: it will
remove any of the substrings <code>"#", '"""', "'''"</code> from the input. The removal
happens only once, <i>in order</i>. So, the a-ha: you can actually use <code>"""</code> by
giving something like <code>"'''""</code>. The server will remove the single quotes and
keep the double ones.
</p>

<p>
Unfortunately I don&rsquo;t have the actual solution at hand since I can&rsquo;t find it in
my REPL history, but the basic idea was to just use a simple payload like
<code>print("__import__('os').system('sh')")</code> and then figure out how to make that
into a palindrome. I think I settled on something like
<code>""";";""";&lt;code&gt;;""";&lt;reverse of code&gt;;""";";"""</code>. Notice how <code>""";";"""</code> is
interpreted to be the string <code>';";'</code> when evaluated normally, but also provides
an end for the triple-quote: <code>..."""; ";" ""</code>.
</p>

<p>
(Another idea would be to use some trickery involving the escape character
<code>r"\"</code> which could potentially escape/unescape strings depending on order, but I
didn&rsquo;t think of that at the time.)
</p>
</div>
</div>

<div id="outline-container-org25e6339" class="outline-3">
<h3 id="org25e6339">baby:Hashfun</h3>
<div class="outline-text-3" id="text-org25e6339">
<p>
Trivial welcome-task I had missed until <code>poiko</code> reminded me. It basically does
<code>print(flag ^ flag[4:])</code> (if one were able to do that in Python). You know
<code>flag</code> starts with <code>CSR{</code> which gives you the next four bytes, and those gives
the next four, and so on.
</p>
</div>
</div>

<div id="outline-container-orgef031ac" class="outline-3">
<h3 id="orgef031ac">crypto:dtls</h3>
<div class="outline-text-3" id="text-orgef031ac">
<p>
The task gives you a pcap file and this shell script:
</p>

<div class="org-src-container">
<pre class="src src-bash"> <span style="color: #5B6268;"># </span><span style="color: #5B6268;">/usr/lib/libc.so.6|head -n 1</span>
 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">GNU C Library (GNU libc) stable release version 2.31.</span>

 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">clone</span>
 <span style="color: #ECBE7B;">git</span> clone https://github.com/eclipse/tinydtls.git dtls

 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">build</span>
 <span style="color: #ECBE7B;">cd</span> dtls &amp;&amp; autoconf &amp;&amp; autoheader &amp;&amp; ./configure &amp;&amp; <span style="color: #ECBE7B;">make</span> &amp;&amp; <span style="color: #ECBE7B;">cd</span> ..

 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">listen</span>
 tcpdump -i lo  port <span style="color: #da8548; font-weight: bold;">31337</span> -w dump.pcap &amp;

 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Wait for tcpdump...</span>
 <span style="color: #ECBE7B;">sleep</span> <span style="color: #da8548; font-weight: bold;">2</span>

 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">serve</span>
 dtls/tests/dtls-server -p <span style="color: #da8548; font-weight: bold;">31337</span> &amp;

 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">send flag</span>
 <span style="color: #ECBE7B;">cat</span> flag.txt|dtls/tests/dtls-client 127.0.0.1 -p <span style="color: #da8548; font-weight: bold;">31337</span>
</pre>
</div>

<p>
I got the repo and looked around. I know it implements basic TLS over UDP, but
ignored all that. The first thing I searched for was RNG. It doesn&rsquo;t use
cryptographic source of random numbers but instead will just use <code>srand()</code> and
<code>rand()</code> from <code>libc</code> (as hinted to in the script above). That&rsquo;s a problem in
and by itself.
</p>

<p>
But it also turns out that the code is buggy, for example it initializes the RNG
with <code>dtls_prng_init((unsigned long)*buf)</code>, where <code>buf</code> was read to from
<code>/dev/urandom</code>. It&rsquo;s probably <i>intending</i> to use a <code>long</code> for the seed, but guess
what? <code>buf</code> is a <code>char</code> array, so it&rsquo;s actually just using a single byte for the
seed to generate all those important crypto bytes.
</p>

<p>
Now, how to actually attack it. I knew I didn&rsquo;t want to actually interact
with TLS, because TLS is web and web is a hell run by committees, so
instead I did the following:
</p>

<ul class="org-ul">
<li>Make it print out the random bytes it generates. Run the script and compare
it with the given pcap to figure out where those numbers go and what they
should actually be.</li>
<li>Trivially brute the seed.</li>
<li>Modify the library to load its seed from an environment variable so I could
run the client and server with fixed seeds.</li>
<li>Force its internal time function to return 0, as I can see from the pcap
that&rsquo;s what it used there. (It actually tries to use integer seconds since the
start of the program, thus 0 since the transfer happens immediately.)</li>
</ul>

<p>
I ran the script again and compared my pcap with the one given. It&rsquo;s generating
and using the same numbers, uses the same cookie, etc. So then I simply copied
the final encrypted packet from the pcap file and put it into the source code
with an ugly hack like this:
</p>

<div class="org-src-container">
<pre class="src src-c"> <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">bufzzz</span><span style="color: #51afef;">[]</span> = <span style="color: #98be65;">"...stuff..."</span>;

 <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">int</span>
 <span style="color: #c678dd;">decrypt_verify</span><span style="color: #51afef;">(</span><span style="color: #ECBE7B;">dtls_peer_t</span> *<span style="color: #dcaeea;">peer</span>, <span style="color: #ECBE7B;">uint8</span> *<span style="color: #dcaeea;">packet</span>, <span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">length</span>,
            <span style="color: #ECBE7B;">uint8</span> **<span style="color: #dcaeea;">cleartext</span><span style="color: #51afef;">)</span>
 <span style="color: #51afef;">{</span>
   <span style="color: #51afef;">if</span> <span style="color: #c678dd;">(</span>packet<span style="color: #98be65;">[</span><span style="color: #da8548; font-weight: bold;">0</span><span style="color: #98be65;">]</span> == <span style="color: #da8548; font-weight: bold;">0x17</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
     printf<span style="color: #98be65;">(</span><span style="color: #98be65;">"pulling the old switcharoo\n"</span><span style="color: #98be65;">)</span>;
     packet = bufzzz;
     length = <span style="color: #da8548; font-weight: bold;">84</span>;
   <span style="color: #c678dd;">}</span>

   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">...</span>
</pre>
</div>

<p>
For some reason (that I don&rsquo;t care about) this causes TinyDTLS&rsquo; own debug
printing of the message to get messed up, so I also had to print the cleartext
myself at the end of the function. Out comes the flag. No TLS needed (thank
God).
</p>

<p>
This was a pretty cool task. It was practical and &ldquo;real-world&rdquo; but without
feeling contrived and without there being JavaScript or any web frameworks
involved. It was possibly the &ldquo;cleanest&rdquo; real-world-y task I&rsquo;ve seen. Well done
to the task author.
</p>
</div>
</div>

<div id="outline-container-org15dd5d4" class="outline-3">
<h3 id="org15dd5d4">web:Yanote</h3>
<div class="outline-text-3" id="text-org15dd5d4">
<p>
I didn&rsquo;t solve this one. I failed it. Not only did I fail it technically, but I
failed it <i>mentally</i>, which is probably worse. But I worked on it for a while so
I&rsquo;m still going to write about it. It triggered all sorts of feelings of
inadequacy and failure that you wouldn&rsquo;t believe.
</p>

<p>
All because of this &ldquo;web&rdquo; tag.
</p>

<p>
The &ldquo;web&rdquo; tag usually means &ldquo;use educated guesses for any blackbox behavior&rdquo; but
to me it usually reads as &ldquo;realize that nobody agrees with what you think is
reasonable.&rdquo; It reads &ldquo;smell that? Take a deep whiff, that&rsquo;s the smell of
learned helplessness, baby.&rdquo;
</p>

<p>
Clue: the server says &ldquo;invalid CRC-HMAC&rdquo; if you give it an invalid cookie.
</p>

<p>
Ignore the pedantic fact that it would normally be called <code>HMAC-&lt;name&gt;</code> and
&ldquo;CRC&rdquo; is very non-specific, kind of like just saying &ldquo;HASH.&rdquo;
</p>

<p>
However CRCs are more fun than hashes in that they&rsquo;re easier to play around with
computationally. So for a second I dared to dream about some sort of semi-fun
task of trying to figure out the modulus and key and all the other constants of
some unknown <code>HMAC(key, ipad, opad, H=CRC(modulus, a, b))</code> given an <code>oracle(x) =
HMAC(key, A+x+B)</code>. That would have been pretty nice actually.
</p>

<p>
So my approach was all wrong. Because I started to hear this &ldquo;looOOooOOoOool&rdquo;
coming from a dark corner of my mind: the &ldquo;web&rdquo; tag coming back to haunt me. So
maybe none of that cool stuff. Maybe it&rsquo;s just&#x2026;straight up CRC-32&#x2026;? Well,
yes and no.
</p>

<p>
See, I hate this. Instead of &ldquo;figuring something out&rdquo; you have to guess what
<i>they</i> mean about what that something is. Since it&rsquo;s &ldquo;web&rdquo; and in web they tend
to not be too particular about things, HMAC might mean something else.
Potentially it could be a homegrown custom HMAC, potentially it could be
something else entirely. It&rsquo;s not even given that it does <code>HMAC(&lt;key&gt;,
&lt;pickle-data&gt;)</code>. For all you know it could do <code>F(&lt;key&gt;, &lt;username&gt; + ":" +
&lt;permission&gt;)</code> or whatever. Hell, maybe it&rsquo;s not even a CRC! Maybe it&rsquo;s just
<code>adler32(&lt;data&gt; + &lt;secret&gt;)</code>&#x2026;
</p>

<p>
Okay, relax. Start testing some basic stuff.
</p>

<p>
I figured out it had normal CRC behavior at least. It was, as they say,
affine-ish. Working with polynomials over \(\mathbb{Z}_2\), \(CRC(x + y) = CRC(x) +
CRC(y) + K_{b}\) where \(K_{b}\) is a constant that depends on the <i>byte-lengths</i> of
<code>x</code> and <code>y</code> (technically on their xor difference?). You&rsquo;d expect this to work for
any HMAC based on a CRC too. This allows you to (easily) log in as admin (but on
the admin page I just found people doing &ldquo;test post pls ignore&rdquo; and being
generally &ldquo;????????&rdquo;).
</p>

<p>
But when I actually tried to &ldquo;solve&rdquo; the blackbox function completely, I kept
getting wrong constants everywhere. And I didn&rsquo;t know what was wrong, didn&rsquo;t
know if it&rsquo;s because I had bugs in the old code I was using (some <code>GF2[X]</code>
implementation from way back), or had some wrong assumption.
</p>

<p>
After a while I suspected there was no HMAC and maybe just a straight up unknown
CRC, which frustrated me even more because if so, then this should be easy, no?
What if something else is different? I spammed random stuff trying to figure out
the modulus for the CRC from the constants I was getting out, double-checked my
math&#x2026; I even wondered if you were supposed to birthday-hammer user-create to
find a duplicate checksum, and maybe that would finally reveal what was going
on, got completely lost&#x2026;
</p>

<p>
Getting full control over the cookie <i>is</i> trickier, but in my more clear-headed
state I think it&rsquo;s possible without solving the black-box function as I was
trying to do. I believe all you need is in the relationship. You can get all the
constant <code>K</code> terms you need by making three users that xor to zero for any given
length. For an unknown CRC, for three constants \(K_i\), \(K_{i+1}\) and \(K_{i+2}\)
(that you&rsquo;d get from <code>("0","q","A")</code> for example, since they xor to 0), then you
can find the modulus as a factor of \(x^8 K_{i+2} + (x^8+1) K_{i+1} + K_{i}\)
(does that work? Now I&rsquo;m not sure, I&rsquo;m copying a note&#x2026;), then the relationship
between the various \(K_i\) as \(K_n = K_0 \frac{x^n-1}{(x-1) x^{n-1}} \pmod M\)
(TODO: math might be wrong), and you should have everything you need.
</p>

<p>
Then you make usernames that xor together to be your pickle payload (the server
accepted non-printables in username) and change the byte for the username length
(this last part is a pen-and-paper mess, so it&rsquo;s not something I&rsquo;d actually try
unless I was sure). The stuff after the byte <code>0x2e (".")</code> in the pickle data is
ignored, so it&rsquo;s fine if the cookie ends with garbage. This was probably the
intended solution, though it&rsquo;s a bug-prone approach, maybe a bit painful to
implement.
</p>

<p>
However I basically just got so frustrated with not getting the math to work out
(I mean, I couldn&rsquo;t even figure out the damn <i>modulus</i>!<sup><a id="fnr.11" class="footref" href="#fn.11" role="doc-backlink">11</a></sup>) and debugging my
own code that I gave up. I have an issue with committing to guesses unless I
have a reasonable idea it will work. <i>Failure-sensitive</i>. Besides, engaging with
guessy stuff feels dirty unless you vibe some level of mental harmony with the
task author (which I didn&rsquo;t).
</p>

<p>
Dirty confession: I even debased myself and tried to brute force a 32-bit key
against HMAC-CRC32 using the usual constants, but it didn&rsquo;t work. That was the
last straw. After that I signed off and went for a long walk to hang out with
the ducks by the river (not a metaphor&#x2013;there are actual ducks).
</p>

<p>
<i>Addendum:</i> it was plain CRC-32, and the &ldquo;HMAC&rdquo; just a salt being added to the
data bytestring. Prefix or postfix salt? Length of salt? Well, it&rsquo;s web, so the
answer could be to just guess and try it, and if that doesn&rsquo;t work, guess
something else.
</p>
</div>
</div>
</div>

<div id="outline-container-org2e1cfdb" class="outline-2">
<h2 id="org2e1cfdb">BalsnCTF 2020</h2>
<div class="outline-text-2" id="text-org2e1cfdb">
</div>
<div id="outline-container-balsn2020" class="outline-3">
<h3 id="balsn2020">General Comments</h3>
<div class="outline-text-3" id="text-balsn2020">
<p>
Another great CTF!
</p>

<p>
But yet again I have some Debbie Downer comments.
</p>

<p>
Disclaimer: this is clearly a top-tier CTF, close to ~100 points, so my main
criticisms below are more subjective and personal than objective. I will be
playing the part of <a href="https://www.youtube.com/watch?v=48aUMXifAn8">Wolfgang</a>, so I might seem a lot more negative than what is
deserved.
</p>

<p>
The difficulty of <i>certain</i> tasks seemed to come from them simply being the
composition of several sub-tasks that <i>in some cases</i> weren&rsquo;t even related. I am
not a fan of that at all. It&rsquo;s exhausting and it feels like a really cheap way
to increase difficulty. <a href="#orgb56f0da">Happy Farm</a> is the obvious example<sup><a id="fnr.12" class="footref" href="#fn.12" role="doc-backlink">12</a></sup>. Instead of
having tasks T1, T2, T3 that are all fairly independent problems, they&rsquo;re
composed or chained in some way to make a much more work-intensive task. This
joined task can even appear more difficult than the most difficult in the
set<sup><a id="fnr.13" class="footref" href="#fn.13" role="doc-backlink">13</a></sup>, yet <i>it won&rsquo;t feel that rewarding</i>.
</p>

<p>
That&rsquo;s just a strong personal preference, perhaps other people think it&rsquo;s cool
and the bee&rsquo;s knees. I preferred <a href="#orge71fea0">N1CTF2020</a> for example, which had a similar
difficulty level, but where none of the tasks seemed &ldquo;artificially&rdquo; difficult by
composition or layering.
</p>

<div class="org-src-container">
<pre class="src src-python">  <span style="color: #51afef;">import</span> random
  random.seed(<span style="color: #c678dd;">int</span>(<span style="color: #c678dd;">input</span>()))

  <span style="color: #51afef;">assert</span> \
  b<span style="color: #98be65;">"""As an extreme example, what if every category was just a single chained</span>
<span style="color: #98be65;">  monster-task? No flag until you do them all. I personally am /much/ more</span>
<span style="color: #98be65;">  comfortable on the other end of this spectrum, where it's a series of smaller</span>
<span style="color: #98be65;">  bite-sized puzzles. Composing small but hard-ish puzzles isn't /that/ difficult.</span>
<span style="color: #98be65;">  Here's one, for example."""</span> == random.getrandbits(<span style="color: #da8548; font-weight: bold;">8</span>*<span style="color: #da8548; font-weight: bold;">328</span>).to_bytes(<span style="color: #da8548; font-weight: bold;">328</span>, <span style="color: #98be65;">'big'</span>)
</pre>
</div>

<p>
Another consequence is one ends up with less number of tasks total, so there&rsquo;s
less to choose from or pick what order to do things in.
</p>

<p>
A lot of the frustration behind the above rant comes from all the time I wasted
on <code>Patience I</code>, which I only got a partial solution to, and the exhaustion that
set in from solving the three-in-one task <a href="#orgb56f0da">Happy Farm</a>. As it were I felt really
burned out and didn&rsquo;t do anything at all productive on Sunday, except to assist
<code>poiko</code> with one of his solves. Well. I also discovered several mice in my
apartment this weekend, which was&#x2026;not fun.
</p>

<p>
Anyway, <code>aeshash</code> and <code>IEAIE</code> were both really cool, and I look forward to
actually doing them outside of the CTF.
</p>

<p>
We ended up placing 12th, so we just missed the mark for the coveted 13th
position.
</p>
</div>
</div>

<div id="outline-container-orgb56f0da" class="outline-3">
<h3 id="orgb56f0da">Happy Farm</h3>
<div class="outline-text-3" id="text-orgb56f0da">
<p>
A layered crypto task. It&rsquo;s simply the concatenation of three totally different
crypto tasks. Unlike some other such problems (I seem to remember some chained
RSA problem from either a Dragon CTF or a DefCon qualifier?) the systems here
aren&rsquo;t even related. In my opinion it really should have been given as three
separate tasks, even if they were capped at a third of the points.
</p>

<p>
But as it were, this took too much time and exhausted most of my energy/hype.
</p>

<p>
Also, the task had the added <i>fun flavour</i> of the code being about seeds and
fertilizers to grow onions, drawing numbers as ASCII-art bulbs and so forth. It
stopped being fun after the first subtask.
</p>
</div>

<div id="outline-container-org6cd3b2f" class="outline-4">
<h4 id="org6cd3b2f">Task 1: AES CBC</h4>
<div class="outline-text-4" id="text-org6cd3b2f">
<p>
After spending some time reading the code (which is a hot mess) this task
becomes pretty simple. All you need to know is how CBC mode works with AES.
</p>

<p>
Your have an oracle you can query twice. You give it <code>(n, iv, data)</code> with
<code>n=0..8999</code> and it gives back \(\mathtt{aescbc}_{k,iv}^n(data)\) for an unknown key
\(k\). That is: AES is initialized in CBC mode with the unknown <code>k</code> and the given
<code>iv</code>. It then iteratively encrypt <code>data</code> <code>n</code> times. The goal is to
find \(\mathtt{aescbc}_{k,siv}^{9000}(sdata)\) for some known \((siv,sdata)\). You may
not give it \(sdata\) to encrypt directly.
</p>

<p>
So first you give it something like <code>(8999, siv[0]^sdata[0] || siv[1:], b'0' ||
sdata[1:])</code>. The xor is just to make the data not match <code>sdata</code>, but it will be
undone by the CBC mode. Then you give it <code>(1, response[-16:], response)</code> (last
block is the IV for next block) and the result is the answer.
</p>
</div>
</div>

<div id="outline-container-org488a58c" class="outline-4">
<h4 id="org488a58c">Task 2: RSA and Euler hacks</h4>
<div class="outline-text-4" id="text-org488a58c">
<p>
The server sets \(e = 3\), \(s = (2^{1023})^e \pmod n\), and \(d = 1/3
\pmod{\phi(n)}\). \(n\) is composed of two 512-bit primes. Note that modulus \(n\) is
initially unknown. Note also that \(x^d \pmod n\) is &ldquo;sort-of&rdquo; like \(\sqrt[3]{x}
\pmod n\).
</p>

<p>
The serves gives you \(s\) and asks for an integer \(k \in [0,8999]\). It then gives
you \(r = s^{d^k}\), which is &ldquo;sort-of&rdquo; like taking the cube root \(k\) times.
</p>

<p>
Finally you can feed it a full pair \((x,j)\) and it will calculate \(y = x^{d^j}
\pmod n\) but with some of the low-order bits hidden. This whole thing was a bit
convoluted. There&rsquo;s ASCII drawings of onions that you use to figure out where
the missing bits are and blah blah. You basically
get \(y\) minus some &ldquo;small&rdquo; random number on the order of 2<sup>332</sup>-ish (if I
recall correctly). And a final caveat: the \(j\) you give in this step has to be
less than or equal to the \(k\) you gave initially.
</p>

<p>
The goal is to find \(s^{d^{9000}} \pmod n\).
</p>

<p>
First, to do anything, we need to find \(n\), which we can do with what I call
Euler hacks. We know that \(n' = 2^{3\cdot 1023} - s\) contains \(n\) as a factor.
This number is too big to try to factor out \(n\) directly, but we have another
number that also has \(n\) as a factor. Because \(r\) is &ldquo;sort-of&rdquo; like iteratively
taking the cube root of \(s\) (which was itself a cube, because \(e=3\)), if we
repeatedly cube it back up and subtract the known remainder we&rsquo;ll get a factor
of \(n\), for example in \(r^{3^{k-1}} - 2^{1023}\). This last number can&rsquo;t be
calculated directly if the \(k\) is large, but we can do it under \(\pmod{n'}\)
which will preserve the factor of \(n\). I suspect the caveat mentioned above with
\(j \le k\) is simply there to force you to give a large initial \(k\) to make this
step a little bit harder? Finally we take the <code>gcd</code> of these numbers and get <code>n</code>
(possibly multiplied by some small factor).
</p>

<div class="org-src-container">
<pre class="src src-python">  <span style="color: #dcaeea;">nk</span> = <span style="color: #da8548; font-weight: bold;">2</span>**(<span style="color: #da8548; font-weight: bold;">3</span>*<span style="color: #da8548; font-weight: bold;">3</span>*<span style="color: #da8548; font-weight: bold;">11</span>*<span style="color: #da8548; font-weight: bold;">31</span>) - s
  <span style="color: #dcaeea;">nj</span> = <span style="color: #c678dd;">pow</span>(r, <span style="color: #da8548; font-weight: bold;">3</span>**<span style="color: #da8548; font-weight: bold;">8997</span>, nk) - <span style="color: #da8548; font-weight: bold;">2</span>**(<span style="color: #da8548; font-weight: bold;">11</span>*<span style="color: #da8548; font-weight: bold;">31</span>) <span style="color: #5B6268;"># </span><span style="color: #5B6268;">I gave j=8999</span>
  <span style="color: #dcaeea;">n</span> = gcd(nk, nj)

  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">The exponents are factored becaue I thought maybe the fact that 1023</span>
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">contained a factor of 3 would be relevant, but it wasn't.</span>
</pre>
</div>

<p>
Anyway, with \(n\) known this reduces to a lattice/Coppersmith-type problem. In
the second step I gave \(k=8999\) and got \(r = s^{d^{8999}} \pmod n\). In the last
step I gave \(j=8999\) again but now using \(x=2^{1023}\) as the base number (i.e. a
cube root of \(s\)), which gives me back \(y\) as an &ldquo;approximation&rdquo; of the target
number \(s^{d^{9000}} \pmod n\).
</p>

<p>
The mask for the unknown bits in this approximation is
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dcaeea;">mask</span> = 0xf00000000ffff0000ff00ffff00ffff00fffffffffffff000ffffffffffffffff00fffffffffffff0ff
</pre>
</div>

<p>
Because \(y^3 = r \pmod n\) I can use this equation and Sage&rsquo;s <code>.small_roots()</code>. I
didn&rsquo;t really think about doing anything else, I just wanted it to end. However,
the missing bits are not contiguous: if treated as a contiguous block then it&rsquo;s
maybe a little bit over what a standard out-of-the-box Howgrave-Coppersmith
implementation can handle. I wanted to avoid introducing more variables for the
bit pattern and I also didn&rsquo;t want to sit there and have to fiddle with magic
parameters hoping to get lucky. But &ldquo;brute forcing&rdquo; the first hex
character seemed to be enough. E.g. in <code>sage</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">print</span>(<span style="color: #98be65;">"small rootsin': "</span>)
<span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">16</span>):
  <span style="color: #51afef;">print</span>(i, end=<span style="color: #98be65;">' '</span>, flush=<span style="color: #a9a1e1;">True</span>)
  <span style="color: #dcaeea;">rewt</span> = ((c + i*<span style="color: #da8548; font-weight: bold;">2</span>^<span style="color: #da8548; font-weight: bold;">328</span> + x)^<span style="color: #da8548; font-weight: bold;">3</span> - b).small_roots(X=<span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">300</span>, epsilon=<span style="color: #da8548; font-weight: bold;">0.05</span>)
  <span style="color: #51afef;">if</span> rewt:
    <span style="color: #51afef;">print</span>(<span style="color: #98be65;">'thank god... You may now have a snack'</span>)
    <span style="color: #51afef;">break</span>
</pre>
</div>

<p>
So <code>y + i*2^328 + rewt[0]</code> is the solution.
</p>
</div>
</div>

<div id="outline-container-org23d1623" class="outline-4">
<h4 id="org23d1623">Task 3: Borked RCA</h4>
<div class="outline-text-4" id="text-org23d1623">
<p>
Thankfully, this last layer was very easy. By now I was really sick of this
whole task.
</p>

<p>
Long story short, you can query an oracle four times, giving it a <code>k</code> each time
(<code>k</code> has the usual constraints). It then does something like this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">blah</span>(secret, k):
  <span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">R</span> = secret[:<span style="color: #c678dd;">len</span>(secret)//<span style="color: #da8548; font-weight: bold;">2</span>], secret[<span style="color: #c678dd;">len</span>(secret)//<span style="color: #da8548; font-weight: bold;">2</span>:]
  <span style="color: #51afef;">for</span> _ <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(k):
    <span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">R</span> = R, bytes_xor(L, <span style="color: #51afef;">self</span>.rc4_encrypt(R))
  <span style="color: #51afef;">return</span> L+R
</pre>
</div>

<p>
And gives you the result. The goal is to find the result of <code>blah(secret,
9000**3)</code>.
</p>

<p>
<code>rc4_encrypt</code> is <i>supposed</i> to be a standard RC4 implementation initialized with
an unknown key. (I.e. it generates <code>len(plaintext)</code> bytes of stream cipher
output and xors it into the plaintext.) But if you&rsquo;re lucky like me, you notice
this little nugget right away, before you&rsquo;ve even parsed what the task is about:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">swap</span>(<span style="color: #51afef;">self</span>, a, b):
  <span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">b</span> = b, a
</pre>
</div>

<p>
I think I actually laughed when I saw this innocent little method. It&rsquo;s trying
so hard not to be noticed. Aww, it&rsquo;s so cute.
</p>

<p>
And but so. The RC4 implementation never really swaps elements around. Which means it
will have a really short order. Let&rsquo;s look at it:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dcaeea;">i</span> = (i + <span style="color: #da8548; font-weight: bold;">1</span>) % <span style="color: #da8548; font-weight: bold;">256</span>
<span style="color: #dcaeea;">j</span> = (j + s[i]) % <span style="color: #da8548; font-weight: bold;">256</span>
<span style="color: #51afef;">self</span>.swap(s[i], s[j]) <span style="color: #5B6268;"># </span><span style="color: #5B6268;">lol!</span>
output.append(s[(s[i] + s[j]) % <span style="color: #da8548; font-weight: bold;">256</span>])
</pre>
</div>

<p>
Every 256 iterations, the <code>i</code> will be 0 and <code>j</code> will be <code>sum(range(256))%256 ==
128</code>. Meaning that every <i>512</i> iterations we&rsquo;ll have \(j=i=0\) and it will repeat.
</p>

<p>
OK. So. It&rsquo;s trivial to find <code>secret</code>: just give it <code>k=0</code> and it won&rsquo;t encrypt
it. I think <code>secret</code> was 240 bytes long, so to find the order of <code>blah</code> we just
need to align things&#x2026;lcm with the order&#x2026;hm divide by 2&#x2026;blah blah boring
details. Long story short, <code>blah(secret, 9000**3) == secret</code>. It&rsquo;s just what
came out of the first oracle query. Almost a bit of an anti-climax, really.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc53e099" class="outline-3">
<h3 id="orgc53e099">The Last Bitcoin</h3>
<div class="outline-text-3" id="text-orgc53e099">
<p>
Proof-of-work Python script that asks you to find a string <code>X</code> such that <code>sha256(random_token +
X)</code> starts with 200 zero bits.
</p>

<p>
That part is straightforward and clearly impossible.
</p>

<p>
Then you notice that if you give it such a string it exits with error code 1
indicating success. Python also exists with 1 if it gets an uncaught exception.
And it will give such an exception if you give it non-ascii input. So I simply
typed <code>æ</code> and got the flag.
</p>
</div>
</div>

<div id="outline-container-orge876fdd" class="outline-3">
<h3 id="orge876fdd">The Danger of Google&rsquo;s Omnipotence</h3>
<div class="outline-text-3" id="text-orge876fdd">
<p>
This is really <code>poiko</code>&rsquo;s solve, he did the reverse, provided all the data, and so
on, I just helped with the last part in figuring out how to reduce the magic
operation to something tractable.
</p>

<p>
The problem at bird&rsquo;s eye is, I was told, something like this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dcaeea;">k</span> = 0xfad9c53c828be5dafc765d4a52a54168442b6f57569db5f320a45d0d0e39d92d04284087fe2e36da1375d55e6e4e9f746cf9d9916c791e0467dc0aedf77581d7e1ab342f99e49f4c684fd7424e806cc2fb1dd54c614487b6a3909dc469f76eb8df050f3928d4c371d8aace5c81fbb1e467b987ec5ae1f5ecd0b8ffe69369edc9
<span style="color: #dcaeea;">flag</span> = &lt;some <span style="color: #da8548; font-weight: bold;">2</span>^<span style="color: #da8548; font-weight: bold;">16</span> array&gt; <span style="color: #5B6268;"># </span><span style="color: #5B6268;">secret</span>
<span style="color: #dcaeea;">A</span> = &lt;some <span style="color: #da8548; font-weight: bold;">2</span>^<span style="color: #da8548; font-weight: bold;">16</span> array&gt; <span style="color: #5B6268;"># </span><span style="color: #5B6268;">known</span>

<span style="color: #dcaeea;">B</span> = flag
<span style="color: #51afef;">for</span> _ <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(k):
  <span style="color: #dcaeea;">B</span> = strange_matmul(B, A)

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">B is output here</span>
</pre>
</div>

<p>
Reversing <code>strange_matmul</code> and figuring out what it does is the main problem,
which <code>poiko</code> already did. But as a last step we&rsquo;d need to strength-reduce
<code>strange_matmul</code> to some actual math, like a real matrix multiplication for
example, and then we have <code>B = flag * A^k</code> which can hopefully be inverted.
</p>

<p>
<code>poiko</code> gave me sort-of pseudocode for <code>strange_matmul</code>:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">strange_matmul</span>(m, n):
    <span style="color: #dcaeea;">out</span> = []
    <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">256</span>):
        <span style="color: #51afef;">for</span> j <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">256</span>):
            <span style="color: #dcaeea;">val</span> = <span style="color: #da8548; font-weight: bold;">0</span>
            <span style="color: #51afef;">for</span> k <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">256</span>):
                <span style="color: #dcaeea;">v1</span> = m[i*<span style="color: #da8548; font-weight: bold;">256</span>+k]
                <span style="color: #dcaeea;">v2</span> = n[k*<span style="color: #da8548; font-weight: bold;">256</span>+j]
                <span style="color: #51afef;">if</span> v1 == <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #51afef;">or</span> v2 == <span style="color: #da8548; font-weight: bold;">0</span>:
                    <span style="color: #51afef;">continue</span>
                <span style="color: #dcaeea;">val</span> = strange_add(val, a_inv[(a[v1] + a[v2]) % <span style="color: #da8548; font-weight: bold;">7</span>**<span style="color: #da8548; font-weight: bold;">3</span>])
            out.append(val)
    <span style="color: #51afef;">return</span> out
</pre>
</div>

<p>
Where <code>strange_add</code> adds the numbers as if they were in base-7 but without using
carry, and <code>a</code> and <code>a_inv</code> were some lookup tables he also shared. I don&rsquo;t
remember if they were in the code or something he constructed.
</p>

<p>
Anyway, so it looks like a normal matrix multiplication, but the element-wise
operations aren&rsquo;t carried out using normal arithmetic. So we both played around
a little with <code>a</code> and <code>a_inv</code> and there were definite group-like properties. I
even wrote a little utility class so I could do arithmetic with such numbers
directly and play with them in the REPL. At first it &ldquo;felt&rdquo; like a commutative
additive group, with <code>0</code> almost being the identity except for <code>0 + 0 = 1</code> which
meant it wasn&rsquo;t really associative either, because \((x+0)+0 \ne x+(0+0)\). <code>a</code>
was a permulation, but <code>a_inv</code> was not as <code>a_inv[0] == 1</code> when it seemed like it
should have been 0. This makes sense from the above code where 0 is avoided.
Anyway, from the <code>strange_add</code> I strongly suspected it was a mapping into the
åker<sup><a id="fnr.14" class="footref" href="#fn.14" role="doc-backlink">14</a></sup> \(\mathbb{F}_{7^3}\) where the numbers represented the coefficients of
a qudratic polynomial over \(\mathbb{F}_{7}\). If so, what&rsquo;s the modulus?
</p>

<p>
\(x^3\) in \(\mathbb{F}_{7}[X]/(x^3 + P)\) should become \(-P\) where \(deg P < 3\).
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; -fux(<span style="color: #da8548; font-weight: bold;">7</span>)**<span style="color: #da8548; font-weight: bold;">3</span>
[<span style="color: #da8548; font-weight: bold;">6</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">4</span>]
</pre>
</div>

<p>
<code>fux</code> was my utility-class, and <code>fux(7)</code> should represent <code>x</code>, so the modulus is
\(x^3 + 6 x^2 + 4\). (It turns out to also be the default one that <code>sage</code> gives
when constructing <code>GF(7^3)</code>, so that&rsquo;s probably its origin.) With this intuition
behind it the math seems to work out.
</p>

<p>
So, we had 256x256 matrices over \(\mathbb{F}_{7^3}\), and calculating the inverse
is straightforward but boring <code>sage</code> stuff. It would likely have taken many
minutes though, but one thing I lucked out<sup><a id="fnr.15" class="footref" href="#fn.15" role="doc-backlink">15</a></sup> on was I did
<code>.multiplicative_order()</code> on <code>A^-1</code> which <code>sage</code> found quickly as 342. So I
could shave several minutes off the calculation by doing <code>flagimg = B*(A^-1)^(k
% 342)</code>.
</p>

<p>
Anyway, <code>flagimg</code> was a 256x256 noisy image showing a readable flag.
</p>
</div>
</div>

<div id="outline-container-orgbacc28c" class="outline-3">
<h3 id="orgbacc28c">aeshash &amp; IEAIE &amp; Patience I</h3>
<div class="outline-text-3" id="text-orgbacc28c">
<p>
I feel these deserve an entry even though I failed all of them, but I did spend
time on them. I probably didn&rsquo;t praise the first two tasks in this list enough.
They are what I consider actually <i>good</i> crypto tasks of high difficulty (unlike
<a href="#orgb56f0da">Happy Farm</a>). Especially <code>aeshash</code>! <code>aeshash</code>&rsquo;s task author deserves some real
kudos.
</p>

<p>
For either task I had no prior experience and tooling, so I knew it&rsquo;d be a lot
of work for me. I made <code>poiko</code> waste some of his rev-time to make sure I got a
<code>aeshash</code> into Python, which I felt sort of bad about&#x2026; Because I only really
started to scratch the surface of them. And then for most of Sunday I didn&rsquo;t
really have any energy left to continue. However they&rsquo;re the kind of tasks that
makes me want to solve them in my leisure time, which is a real treat.
</p>

<p>
<code>IEAIE</code> was some image encryption scheme using a logistic map and permuations.
It was very sensitive to differential analysis. I did a few things, was able to
reveal a bunch of key-state, but ran into some floating point rounding headaches
in my offline tests. I hate floating point numbers, so I took a sanity break
from it and never really got back. For once the relevant papers are given in the
task description so it&rsquo;s not really a Google-the-Paper challenge.
</p>

<p>
<code>aeshash</code> involved leaking state in a three-round pseudo-AES (each round using
initial state as round-key) and then targeting a specific output. Literally: an
AES hash. I have no idea about this one, which is all the more exciting. Despite
me usually solving the crypto challenges I&rsquo;ve never worked with crypto
profesionally or academically, so I lack a ton of basic knowledge and
experience, such as breaking weakened AES, which is probably like Crypto 101.
But I figured it will be a good place to start learning.
</p>

<p>
I also sunk a ton of time into <code>Patience I</code> doing proper OpenCV for the first
time in my life&#x2026; God, this task sapped me. The composed text which I suspect
is one third of the flag(?) was easy, I also found this strange Morse-ish
sequence but was unable to guess what it really was, noted the spikes in the
lighting but had no idea what they meant either. In the end I even started to
fear the minute little camera shakes were also part of it. Please God. Maybe all
of these things played together in some beautiful and harmonious way in the end,
but really it just felt like three concatenated subtasks that just all had to do
with video?
</p>

<p>
<i>Addendum:</i> having seen spoilers on how <code>Patience I</code> is solved (but not the
others), I can at least say I don&rsquo;t feel bad anymore for not figuring out this
task. It&rsquo;s a bad one. Though I was wrong about the &ldquo;subtasks&rdquo; being separate.
</p>

<p>
The first string you find, the easy part, overlay all the LEDs, was
<code>_q!fitlboEc</code>. I mistakenly thought it might be <code>flag[x::3]</code> or something like
that. (Thus why I thought the three parts were separate.) But apparently it&rsquo;s an
alphabet of sorts, which you index using&#x2026;I don&rsquo;t know, it was unclear exactly
what. And the timing pattern <i>was</i> Morse, but the international extended version
with punctuation, making <code>P=B_=_Q=D</code> which is apparently supposed to mean
&ldquo;replace &lsquo;b&rsquo; with &lsquo;p&rsquo;, and &lsquo;q&rsquo; with &lsquo;q&rsquo;&rdquo;?&#x2026; The logic or motivation behind any
of these things totally escapes me.
</p>

<p>
I even said to <code>poiko</code> while I was working on this task, thinks like &ldquo;hm,
there&rsquo;s a timing pattern here, it feels a lot like Morse, but I&rsquo;m actually going
to be a little bit disappointed if that turns out to be true&#x2026;&rdquo; and &ldquo;it can&rsquo;t
be too escape room-ish, right? It&rsquo;s Balsn, they&rsquo;re good, they wouldn&rsquo;t make
something like that&rdquo; and so on. <a href="https://www.youtube.com/watch?v=_O1hM-k3aUY">Disappointed!</a>
</p>
</div>
</div>

<div id="outline-container-orgb6b0708" class="outline-3">
<h3 id="orgb6b0708">babyrev</h3>
<div class="outline-text-3" id="text-orgb6b0708">
<p>
Again, <code>poiko</code> solved this one, but I helped out a tiny little bit at the end, so I
feel comfortable writing what it was about.
</p>

<p>
Apparently a <code>scala</code> program that seemed to construct an infinite stream by
doing what I would write in Haskell as:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">w</span> <span style="color: #dcaeea;">=</span> [[<span style="color: #da8548; font-weight: bold;">0</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>], [<span style="color: #da8548; font-weight: bold;">0</span>], [<span style="color: #da8548; font-weight: bold;">0</span>], [<span style="color: #da8548; font-weight: bold;">0</span>]]
<span style="color: #c678dd;">stream</span> <span style="color: #dcaeea;">=</span> [<span style="color: #da8548; font-weight: bold;">0</span>] <span style="color: #ECBE7B;">:</span> map (concat <span style="color: #dcaeea;">.</span> map (w <span style="color: #dcaeea;">!!</span>)) stream
</pre>
</div>

<p>
It makes an infinite stream of lists like <code>[0] : [0,1,2,3] : [0,1,2,3,0,0,0] :
[0,1,2,3,0,0,0,0,1,2,3,0,1,2,3,0,1,2,3] : ...</code>. It sums all the sublists in this
stream, extracts index 60107, and takes its remainder under \(2^{62}\). It
converts the resulting number to 4 bytes which becomes an xor-key for flag data.
</p>

<p>
Immediately I smelled a recurrence relation for the sum. Tried and true OEIS tells the
truth: \(a_{n+2} = a_{n+1} + 3 a_{n}\) <sup><a id="fnr.16" class="footref" href="#fn.16" role="doc-backlink">16</a></sup>, and so, starting from \(a_0 = 0\) and \(a_1 =
6\) (for the sum of these lists) gives all that&rsquo;s needed. It can be calculated
linearly in a list, or logarithmically by exponentiation on a 2x2 matrix.
</p>
</div>
</div>
</div>

<div id="outline-container-org18e99b7" class="outline-2">
<h2 id="org18e99b7">DragonCTF 2020</h2>
<div class="outline-text-2" id="text-org18e99b7">
</div>
<div id="outline-container-dragon2020" class="outline-3">
<h3 id="dragon2020">General Comments</h3>
<div class="outline-text-3" id="text-dragon2020">
<p>
My expectations were a bit high, DragonCTF has had some of the best CTFs in the
past. Yet I had the thought that even last year&rsquo;s 24-hour &ldquo;teaser&rdquo; CTF was
better? So a bit mixed feelings. I&rsquo;m not saying this wasn&rsquo;t good but&#x2026;? It&rsquo;s
hard not to vote with one&rsquo;s heart.
</p>

<p>
The difficulty was alright, but it felt like very few tasks in total. Thinking
partly of my poor teammate <code>poiko</code> this time, who seemed to get only a single
pure rev task, and an easy one at that. I know he was hyped and had looked
forward to fiendish VM-in-VMs and unknown architectures. We kept waiting for
more to be released, but alas.
</p>

<p>
For my own sake, <a href="#org73ae512">Frying in motion</a> was an cool idea, tho a bit draining. <a href="#org2ae8c68">Bit Flip 1</a> was easy. <a href="#orgf5a413f">Bit Flip 2 &amp; 3</a> were puzzling, but not the good kind of
puzzling (which motivates me to write code or learn stuff outside of the CTF),
but &ldquo;I feel I just missing some (probably) trivial trick here, oh well next time
I guess&rdquo;-puzzling.
</p>

<p>
Sunday I ended up watching <i>Gilmore Girls</i> and <code>poiko</code> was reduced to doing
Linux stuff and actual hacking. Imagine having to do actual hacking. What&rsquo;s that
about? Sheesh.
</p>

<p>
Anyway, we placed like dumpster tier anyway. Wasn&rsquo;t our weekend, I guess.
</p>
</div>
</div>

<div id="outline-container-org73ae512" class="outline-3">
<h3 id="org73ae512">Frying in motion</h3>
<div class="outline-text-3" id="text-org73ae512">
<p>
I put off this task while looking at the <i>Bit Flip</i> tasks because I kind of
expected implementing it would be an unfun hellhole of tiny bugs. It&rsquo;s one of
those tasks where the idea is simple and/or obvious but it&rsquo;s a pain in the ass
to implement<sup><a id="fnr.17" class="footref" href="#fn.17" role="doc-backlink">17</a></sup>. Not a fan of that.
</p>

<p>
But so: the task involves reversing a <code>strfry()</code> given the output of another
<code>strfry()</code>. Fine, sounds like an RNG task.
</p>

<p>
<code>strfry()</code> does this:
</p>

<div class="org-src-container">
<pre class="src src-c"> <span style="color: #ECBE7B;">char</span> *
 <span style="color: #c678dd;">strfry</span> <span style="color: #51afef;">(</span><span style="color: #ECBE7B;">char</span> *<span style="color: #dcaeea;">string</span><span style="color: #51afef;">)</span>
 <span style="color: #51afef;">{</span>
   <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">init</span>;
   <span style="color: #51afef;">static</span> <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">random_data</span> <span style="color: #dcaeea;">rdata</span>;

   <span style="color: #51afef;">if</span> <span style="color: #c678dd;">(</span><span style="color: #51afef; font-weight: bold;">!</span>init<span style="color: #c678dd;">)</span>
     <span style="color: #c678dd;">{</span>
       <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">state</span><span style="color: #98be65;">[</span><span style="color: #da8548; font-weight: bold;">32</span><span style="color: #98be65;">]</span>;
       rdata.state = <span style="color: #a9a1e1;">NULL</span>;
       __initstate_r <span style="color: #98be65;">(</span>random_bits <span style="color: #a9a1e1;">()</span>,
                      state, <span style="color: #51afef;">sizeof</span> <span style="color: #a9a1e1;">(</span>state<span style="color: #a9a1e1;">)</span>, &amp;rdata<span style="color: #98be65;">)</span>;
       init = <span style="color: #da8548; font-weight: bold;">1</span>;
     <span style="color: #c678dd;">}</span>

   <span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">len</span> = strlen <span style="color: #c678dd;">(</span>string<span style="color: #c678dd;">)</span>;
   <span style="color: #51afef;">if</span> <span style="color: #c678dd;">(</span>len &gt; <span style="color: #da8548; font-weight: bold;">0</span><span style="color: #c678dd;">)</span>
     <span style="color: #51afef;">for</span> <span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; len - <span style="color: #da8548; font-weight: bold;">1</span>; ++i<span style="color: #c678dd;">)</span>
       <span style="color: #c678dd;">{</span>
         <span style="color: #ECBE7B;">int32_t</span> <span style="color: #dcaeea;">j</span>;
         __random_r <span style="color: #98be65;">(</span>&amp;rdata, &amp;j<span style="color: #98be65;">)</span>;
         j = j % <span style="color: #98be65;">(</span>len - i<span style="color: #98be65;">)</span> + i;

         <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c</span> = string<span style="color: #98be65;">[</span>i<span style="color: #98be65;">]</span>;
         string<span style="color: #98be65;">[</span>i<span style="color: #98be65;">]</span> = string<span style="color: #98be65;">[</span>j<span style="color: #98be65;">]</span>;
         string<span style="color: #98be65;">[</span>j<span style="color: #98be65;">]</span> = c;
       <span style="color: #c678dd;">}</span>

   <span style="color: #51afef;">return</span> string;
 <span style="color: #51afef;">}</span>
</pre>
</div>

<p>
(Aside: is it just me or is the GNU style one of the ugliest code styles in
existence?)
</p>

<p>
So <code>strfry()</code> just uses glibc&rsquo;s <code>random_r()</code> stuff, using a 32-byte state
buffer (of which only 28 bytes are used), initialized with a 32-bit seed based
on some CPU clock counter. (<code>random_bits()</code> actually gives less than 32-bits of
actual bits but let&rsquo;s ignore that.)
</p>

<p>
It&rsquo;s clearly a &ldquo;brute the seed&rdquo; sort of task, because even partially reversing
the internal state directly (let&rsquo;s say if it had initialized with 28 bytes of
random data from <code>urandom</code>) just given <code>strfry()</code> output alone is very hard
unless many such calls can be queried in a series. (And even then it would be a
finicky as all hell.)
</p>

<p>
Another thing the task does is it calls <code>strfry()</code> a lot of times on a temporary
string before it does the challenge-response step. The number of resulting
<code>random_r()</code> calls is predictable, but you don&rsquo;t get any output. So, it&rsquo;s &ldquo;brute
the seed&rdquo; and then &ldquo;seek in the RNG stream.&rdquo;
</p>

<p>
Seeking in glibc&rsquo;s <code>random_r()</code> stream turns out to be easy, as it seems to be
just a linear recurrence. It does varying things depending on how many bytes of
state you give it, but all of them are very simple. It&rsquo;s sort of like a more
flexible Mersenne Twister without the output scrambling. For 32-byte state it
will use \(a_{n+7} = a_{n+4} + a_n\) which can be modelled most simply (to me,
anyway) with matrix exponentiation:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #dcaeea;">A</span> = ZZ[<span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">32</span>].matrix([[<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>],
                       [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
                       [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
                       [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
                       [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
                       [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>],
                       [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">0</span>]])

 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">now you can model state after n steps as A**n * state</span>
 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">modulo indexing errors.</span>
</pre>
</div>

<p>
This is the same for seeking in plenty of RNGs whose internals are linear or
&ldquo;affine&rdquo; like xoshiro and MT. Note that the state has the last 7 outputs from
the RNG, which will come in handy. Note also that the RNG discard the lowest
bit when giving actual output. (But due to the lack of scrambling the low order
bits will still be pretty bad by most RNG standards.)
</p>

<p>
Now about the seed. The state is initialized by <code>initstate_r()</code> with \(state_i =
 seed \cdot 16807^i \pmod {2^{31}-1}\).
</p>

<p>
There&rsquo;s plenty of sources of bugs here. One is that it actually starts
outputting at \(state_3\) or something like that, and then iterates in reverse
order from how I set up my vectors, which I should probably have fixed&#x2013;so
that&rsquo;s on me. It also discards the 70 (in our case) first outputs from
<code>random_r()</code> so these have to be taken into account. And of course the mixed
moduli need to be kept separate. Notably care must be taken so numpy doesn&rsquo;t
overflow the seed-modulus.
</p>

<p>
Now to match the <code>strfry()</code> output. For example, given <code>out = strfry(in)</code> with
unique characters, I know that the first random call (<code>i=0</code>) satisfies
<code>random_r() % (len(in) - i) == in.index(out[i])</code>. Then re-do the swap, get a
similar constraint from the next character, and so forth. I did this for the 7
first characters for a 90+ char string to make sure I had enough information to
uniquely determine any seed from a given state. (A potentially more clever idea
would be to use a longer string and only consider even indices, taking only 1
bit from each character, to get constraints that are all mod 2? I didn&rsquo;t think
of that at the time.)
</p>

<p>
I think in the end I had some idiotic thing like:
</p>

<p>
\(( A^{70+n+7} \left[ seed \cdot 16807^i \pmod {2^{31}-1} \right]_{i=0\ldots 6} \pmod {2^{32}})_{7-j} \gg
 1 = index_{j} \pmod {length - j} \pmod {\mathtt{random\_indexing\_errors}}\)
</p>

<p>
I mean&#x2026; It&rsquo;s not pretty. I knew it wouldn&rsquo;t be. Doing this sort of thing 90%
of my time is spent fixing off-by-one errors or putting indices in the wrong
order or something like that. For my test code I had something like:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #5B6268;"># </span><span style="color: #5B6268;">precomputed stuff</span>
 <span style="color: #dcaeea;">start</span> = np.array([<span style="color: #da8548; font-weight: bold;">282475249</span>, <span style="color: #da8548; font-weight: bold;">16807</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">470211272</span>, <span style="color: #da8548; font-weight: bold;">1144108930</span>, <span style="color: #da8548; font-weight: bold;">984943658</span>, <span style="color: #da8548; font-weight: bold;">1622650073</span>], np.uint32)
 <span style="color: #dcaeea;">A</span> = np.array([
   [0xe9373f80, 0xdc7dfb8c, 0x9a732dfd, 0x8e41234d, 0x45478090, 0xe4134087, 0x78b11946],
   [0x78b11946, 0xe9373f80, 0xdc7dfb8c, 0x21c214b7, 0x8e41234d, 0x45478090, 0xe4134087],
   [0xe4134087, 0x78b11946, 0xe9373f80, 0xf86abb05, 0x21c214b7, 0x8e41234d, 0x45478090],
   [0x45478090, 0xe4134087, 0x78b11946, 0xa3efbef0, 0xf86abb05, 0x21c214b7, 0x8e41234d],
   [0x8e41234d, 0x45478090, 0xe4134087, 0xea6ff5f9, 0xa3efbef0, 0xf86abb05, 0x21c214b7],
   [0x21c214b7, 0x8e41234d, 0x45478090, 0xc2512bd0, 0xea6ff5f9, 0xa3efbef0, 0xf86abb05],
   [0xf86abb05, 0x21c214b7, 0x8e41234d, 0x4cdcc58b, 0xc2512bd0, 0xea6ff5f9, 0xa3efbef0],
 ], np.uint32)

 <span style="color: #ECBE7B;">@numba.jit</span>(nopython=<span style="color: #a9a1e1;">True</span>)
 <span style="color: #51afef;">def</span> <span style="color: #c678dd;">find_seed</span>(A, start, m):
   <span style="color: #dcaeea;">seedvec</span> = start.copy()
   <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">32</span>):
     <span style="color: #dcaeea;">out</span> = (A*seedvec).<span style="color: #c678dd;">sum</span>(<span style="color: #da8548; font-weight: bold;">1</span>).astype(np.uint32)
     <span style="color: #dcaeea;">out</span> //= <span style="color: #da8548; font-weight: bold;">2</span>
     <span style="color: #dcaeea;">out</span> %= np.array(<span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">89</span>,<span style="color: #da8548; font-weight: bold;">96</span>), np.uint32)
     <span style="color: #51afef;">if</span> np.<span style="color: #c678dd;">all</span>(out == m):
       <span style="color: #51afef;">return</span> i
     <span style="color: #dcaeea;">seedvec</span> += start
     <span style="color: #dcaeea;">seedvec</span> %= <span style="color: #da8548; font-weight: bold;">2147483647</span>
</pre>
</div>

<p>
However, doing a full brute like this wasn&rsquo;t fast enough against the live
server. It was really close but it required me to get lucky, and DragonCTF has
this super annoying PoW blocker on all their tasks&#x2026; I probably should have
picked apart <code>random_bits()</code> but at this point I just wanted to move on with my
life. I <i>think</i> it might also be possible to thread the various moduli and
simply <i>calculate the seed directly</i> for each index-modulus and then CRT it
(esp. if using the idea noted above), but Lord almighty, the paper work
involved. Yeah, brute forcing is dirty, it doesn&rsquo;t feel rewarding or clean, but
it&rsquo;s a dirty real-worldsy task, so I didn&rsquo;t feel too bad about it.
</p>

<p>
Because this CTF had like 1 rev task, <code>poiko</code> was free to help out, so he wrote
a utility in big boy code to do the above for me while I fixed the remaining
indexical bugs, and I could just use:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"FINDING SEED VROOM VROOM"</span>)
 <span style="color: #dcaeea;">s</span> = <span style="color: #c678dd;">int</span>(subprocess.getoutput(<span style="color: #98be65;">'./BLAS '</span> + <span style="color: #98be65;">' '</span>.join(<span style="color: #c678dd;">str</span>(x) <span style="color: #51afef;">for</span> x <span style="color: #51afef;">in</span> M)))
 <span style="color: #5B6268;"># </span><span style="color: #5B6268;">s = find_seed(M)</span>
</pre>
</div>

<p>
Out comes the seed quick as mercury rain. Then seek the stream as above, then
seek the stream again because you forgot to add +1, then do the final
<code>strfry()</code> on the given string, then realize you&rsquo;re an idiot and <i>reverse</i> the
final <code>strfry()</code> because you misremembered the code, then finally get the flag.
</p>
</div>
</div>

<div id="outline-container-org2ae8c68" class="outline-3">
<h3 id="org2ae8c68">Bit Flip 1</h3>
<div class="outline-text-3" id="text-org2ae8c68">
<p>
Diffie-Hellman between Alice and Bob to get a shared key which is used as an AES key.
</p>

<p>
The stream of numbers \(2^{256} \mathtt{sha256}(x) + \mathtt{sha256}(x+1)\) for
\(x = r, r+2, r+4, \ldots\) is scanned to find a prime. When a prime is found at
\(x\), then the lower 64 bits of \(\mathtt{sha256}(x+1)\) becomes Alice&rsquo;s secret.
The numbers here are big-endian strings of 32 bytes.
</p>

<p>
\(r\) is <code>os.urandom(16)</code> and unknown, but you get to flip arbitrary bits in it
so once it&rsquo;s known you can set it to whatever you want. You&rsquo;re told how many
steps it took in the above sequence to find a prime (simulating a timing
attack), so finding the original \(r\) bit-by-bit is easy, something like:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #51afef;">def</span> <span style="color: #c678dd;">find_next_bit</span>(oracle, num_known, bits_known):
   <span style="color: #dcaeea;">next_bit</span> = <span style="color: #da8548; font-weight: bold;">0</span>
   <span style="color: #51afef;">while</span> <span style="color: #a9a1e1;">True</span>:
     <span style="color: #dcaeea;">next_bit</span> = <span style="color: #da8548; font-weight: bold;">2</span> * next_bit + (<span style="color: #da8548; font-weight: bold;">1</span> &lt;&lt; num_known)
     <span style="color: #dcaeea;">x</span> = oracle(next_bit - bits_known - <span style="color: #da8548; font-weight: bold;">2</span>)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">fetch ABC1111X</span>
     <span style="color: #5B6268;"># </span><span style="color: #5B6268;">if unlucky</span>
     <span style="color: #51afef;">if</span> x != <span style="color: #da8548; font-weight: bold;">0</span>:
       <span style="color: #51afef;">break</span>
   <span style="color: #dcaeea;">y</span> = oracle(next_bit + bits_known)        <span style="color: #5B6268;"># </span><span style="color: #5B6268;">fetch ABx0000X</span>

   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">if C was 0, then oracle(y) fetched at offset +2 closer to the prime</span>
   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">if C was 1, there's a tiny chance for false positive</span>
   <span style="color: #51afef;">return</span> y != x - <span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>

<p>
(Could be made a lot more efficient by making use of past ranges. Probably only
\(1 + \epsilon\) queries is needed for most bits instead of fixed 2 I&rsquo;m doing
here?)
</p>

<p>
But anyway, this basically solves the task, because now you get the prime,
Alice&rsquo;s secret, and Bob&rsquo;s public key is given.
</p>
</div>
</div>

<div id="outline-container-orgda931ae" class="outline-3">
<h3 id="orgda931ae">babykok</h3>
<div class="outline-text-3" id="text-orgda931ae">
<p>
I&rsquo;m a closeted Haskell advocate, I&rsquo;ve played with other dependent type things
like Agda 2, and there&rsquo;s some community overlap, so I recognized it
immediately. However.
</p>

<p>
I&rsquo;ve never used Coq before. I&rsquo;ve never used it before, but I now know that I
hate it. I hate its syntax, its IDE, its logo, I hate all the people who think
making puns on its name is smirk-worthy, and the people who pretend the name
doesn&rsquo;t lend itself to puns. I hate how all the blogs make proving stupid toy
theorems about Peano numbers seem like a fun adventure. I hate myself.
</p>

<p>
I have renewed understanding for beginners when they do stuff like:
</p>

<div class="org-src-container">
<pre class="src src-python"> <span style="color: #51afef;">if</span> i == <span style="color: #da8548; font-weight: bold;">0</span>:
   <span style="color: #dcaeea;">s</span> = <span style="color: #98be65;">"a"</span>
 <span style="color: #51afef;">elif</span> i == <span style="color: #da8548; font-weight: bold;">2</span>:
   <span style="color: #dcaeea;">s</span> = <span style="color: #98be65;">"b"</span>
 <span style="color: #51afef;">elif</span> i == <span style="color: #da8548; font-weight: bold;">3</span>:
   <span style="color: #dcaeea;">s</span> = <span style="color: #98be65;">"c"</span>
 <span style="color: #51afef;">elif</span> ...
</pre>
</div>

<p>
or
</p>

<div class="org-src-container">
<pre class="src src-python"> log(<span style="color: #98be65;">"initializing"</span>)
 <span style="color: #c678dd;">sum</span> = <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>
 <span style="color: #51afef;">for</span> _ <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">100000</span>):
   log(<span style="color: #98be65;">"increasing the index"</span>)
   <span style="color: #dcaeea;">i</span> += <span style="color: #da8548; font-weight: bold;">1</span>
   log(<span style="color: #98be65;">"accumulating sum..."</span>)
   <span style="color: #c678dd;">sum</span> += av[i]**<span style="color: #da8548; font-weight: bold;">2</span> + av[<span style="color: #da8548; font-weight: bold;">2</span>*i + av[i]%<span style="color: #da8548; font-weight: bold;">2</span>]

 log(<span style="color: #98be65;">"solving langlands"</span>)
 solve_langlands()

 log(<span style="color: #98be65;">"printing sum"</span>)
 <span style="color: #51afef;">print</span>(<span style="color: #c678dd;">sum</span>)
</pre>
</div>

<p>
I get it. That&rsquo;s me in Coq.
</p>

<p>
I solved the trivial ones easily. The <code>math_theorem</code> one I just pulled from some
tutorial thing. (Super unrewarding way to solve it, but there you go.) I was
stuck on the last problem for a long time, reading tutorials, blog posts,
looking at other proofs, and so on. I also infected <code>poiko</code> and made him waste
time on it. Both of us wasted several combined hours trying to learn Coq&rsquo;s
syntax and usage for this dumb, pseudo-trivial theorem.
</p>

<p>
In the end we both came up with different proofs for the final theorem at
nearly the same time. Mine was:
</p>

<div class="org-src-container">
<pre class="src src-coq"> intro n. intro l. revert n. induction l as [|? ? IHl]; intro n; destruct n; simpl.
 - intro. apply PeanoNat.Nat.nlt_0_r in H. contradiction.
 - intro. apply PeanoNat.Nat.nlt_0_r in H. contradiction.
 - destruct 1. exists a. auto. exists a. auto.
 - auto with arith.
</pre>
</div>

<p>
It probably makes no sense and looks ridiculous to anyone who knows anything
about Coq.
</p>

<p>
<code>poiko</code>&rsquo;s solution might make more sense (I couldn&rsquo;t say):
</p>

<div class="org-src-container">
<pre class="src src-coq"> unfold lt; intro n; induction n as [| n hn]; intro l.
 - destruct l; simpl. inversion 1. inversion 1. exists a. auto. exists a. auto.
 - destruct l. simpl. * inversion 1. * intros. apply hn. auto with arith.
</pre>
</div>

<p>
I&rsquo;m having a hard time deciding whether this is a good task or not. I mean it
made me despise Coq, and that&rsquo;s not good; I&rsquo;m usually all for ivory tower type
theory stuff. On the one hand, motivating CTF players to learn some
higher-order type theory and theorem proving sounds great, but on the other
hand it feels very arbitrary and polarizing the way this task was put together,
like putting up a poem in Finnish that tells you how to make the flag through
puns&#x2013;free points for anyone who speaks the language, a frustrating Google
hammer experience for the rest.
</p>
</div>
</div>

<div id="outline-container-orgf5a413f" class="outline-3">
<h3 id="orgf5a413f">Bit Flip 2 &amp; 3</h3>
<div class="outline-text-3" id="text-orgf5a413f">
<p>
Similar to <i>Bit Flip 1</i> but Bob&rsquo;s key isn&rsquo;t printed. This ruins the easy
solution. You can still reverse \(r\) as above, so you get a little bit of
control over what the prime becomes as well as Alice&rsquo;s secret, both of which
are of course known, but there&rsquo;s not much else to do.
</p>

<p>
These tasks had me super puzzled. Here&rsquo;s just various notes I made to myself
mentally.
</p>

<p>
The brute forcing options included:
</p>

<ul class="org-ul">
<li>Brute force Bob&rsquo;s 64-bit secret. Nope, not gonna happen.</li>
<li>Brute force hashes to make Alice&rsquo;s secret 0 like a 64-bit PoW task. Also not
gonna happen.</li>
<li>Search the SHA256-stream for primes under which 5 (the generator used) has a
very low order, for example by making \(p-1\) smooth. Given that <i>Bit Flip 3</i>
is just like <i>Bit Flip 2</i> but with the added constraint of strong primes, it
seemed to heavily suggest this was the path. But finding smooth numbers of
this size without sieving you control is near impossible. So this was also
not gonna happen.</li>
</ul>

<p>
I wondered about the <code>(p % 5 == 4)</code> chech in <i>Bit Flip 3</i> &#x2013; like are there any
other constraints for <i>random</i> primes where a given number such as 5 might have
low order in the associated field?
</p>

<p>
The task also specifically imports <code>is_prime()</code> from <code>gmpy2</code>, even though it
uses <code>Crypto.Util.numbers</code> (which has <code>isPrime()</code>). It&rsquo;s the only thing it uses
from <code>gmpy2</code> too. That was curious, but I thought it was just some author
idiosyncracy. Besides, you can&rsquo;t really <i>construct</i> the primes being generated,
you can only pick one from some set of random ones, so again it&rsquo;s not like you
can even begin to think about fooling a standard prime check.
</p>

<p>
All tasks also xors the shared secret with 1337 for seemingly no reason. No
idea why. The shared secret will in &ldquo;almost all&rdquo; cases be a 500+ bit number, of
which the 128 most significant bits are used, so it doesn&rsquo;t matter. (Addendum:
I was wrong here, I totally missed the &ldquo;bug&rdquo; in <i>Bit Flip 3</i>.)
</p>

<p>
IV isn&rsquo;t reused, there doesn&rsquo;t seem to be a meet-in-the-middle, data collection
probably doesn&rsquo;t help.
</p>

<p>
I failed to even find the <i>problem</i> I was supposed to work on, so I just put it
out of my mind.
</p>

<p>
<i>Post-CTF Addendum:</i> after the CTF ended I found out that <i>Bit Flip 3</i> can be
solved trivially because <code>long_to_bytes(x, 16)</code> does something quite
unexpected:
</p>

<div class="org-src-container">
<pre class="src src-python"> &gt;&gt;&gt; long_to_bytes(random.getrandbits(<span style="color: #da8548; font-weight: bold;">513</span>), <span style="color: #da8548; font-weight: bold;">16</span>)[:<span style="color: #da8548; font-weight: bold;">16</span>]
 b<span style="color: #98be65;">'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01'</span>
</pre>
</div>

<p>
This was actually really clever! Ever since I started joining CTFs I&rsquo;ve had a
low-key distaste for <code>long_to_bytes()</code> and how pervasive it is. It feels so
Python 2-y. It&rsquo;s in every crypto task under the sun, so its usage didn&rsquo;t stand
out to me at all, and I never bothered to check up on it in this case. I&rsquo;m
sorry I missed this a-ha moment. Deceptive!
</p>

<p>
However it seems that several people solved <i>Bit Flip 2</i> by &ldquo;brute force the
hashes modulo OSINT.&rdquo; Namely: the BitCoin blockchain has a lot of such hashes,
so you can find hashes there that match the requirements. Although that&rsquo;s a
clever idea, it sort of lowers the task in my estimation greatly if that is the
intended solution. It&rsquo;s just a really unfun way to solve problems. It feels a
lot like &ldquo;enter the MD5 hash in Google&rdquo; or &ldquo;look up the factors on
factordb.com&rdquo; but version 2.0. Big boy OSINT is still OSINT. If anyone has a
programmatic or mathematical solution to <i>Bit Flip 2</i> that doesn&rsquo;t look up
dirty money-laundered power-guzzling hashes from other sources I&rsquo;m very
interested to see what I missed?
</p>

<p>
Not that anyone reads these notes, but hey.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb22615c" class="outline-2">
<h2 id="orgb22615c">HITCON &amp; perfectblue</h2>
<div class="outline-text-2" id="text-orgb22615c">
<p>
Reserving this space. Skipped both of these in favor of reading postmodern
fiction, <a href="https://www.youtube.com/watch?v=OhGUjmYyA58">curling up in bed</a> awash with emo poetry, and going to <a href="https://www.youtube.com/watch?v=GV-WONhEZec">couples therapy</a>
in plays acted out in my own head.
</p>

<p>
But it seems they had cool tasks which I plan to solve off-line between whatever
bouts of depression. PBCTF in particular (got <code>poiko</code> to scrape the tasks as I
was even offline at that point) seemed to have tons of tasty goodies.
</p>
</div>
</div>

<div id="outline-container-org7c4477e" class="outline-2">
<h2 id="org7c4477e">ASIS 2020</h2>
<div class="outline-text-2" id="text-org7c4477e">
</div>
<div id="outline-container-asis2020" class="outline-3">
<h3 id="asis2020">General Comments</h3>
<div class="outline-text-3" id="text-asis2020">
<p>
I was bribed with pizza to rejoin this CTF after two weeks of being largely
offline. I didn&rsquo;t play on Friday, as I was lost in the braindance of <i>Cyberpunk
2077</i>, but was able to quit and reboot into Linux on Saturday.
</p>

<p>
But oof, this CTF had some <i>actual</i> hiccups, not like the fake critiques I&rsquo;ve
unfairly levied against other CTFs above. A bunch of things seemed to have
slipped through Q&amp;A, there were a couple of broken problems and questionable
code in the crypto/ppc sections; <code>poiko</code> also indicated that the rev challenges
were really uninspired, everything boiling down to obfuscated x86 with guessy
elements(?).
</p>

<p>
However, looking at CTFTime now, especially the voting section, it seems almost
like there&rsquo;s reverse group-think going on, like suddenly it&rsquo;s Socially
Acceptable to be Critical or to &ldquo;offset&rdquo; high votes with exaggeratedly low ones,
so everyone&rsquo;s letting off steam. Does this CTF really only deserve 20 points?
That&rsquo;s goddamn vicious. Was it really Ekoparty or e-Jornadas level? No way.
</p>

<p>
Their heart was clearly in the right place. The difficulty level was alright,
and the <i>intent</i> seemed good. Plenty of the tasks were <i>interesting</i>, but sure,
there were <a href="./problems.png">Problems</a> and a couple of tasks with bad &ldquo;quality assurance.&rdquo; I still
feel this CTF was leagues better than OSINT-riddled pub-quiz or escape-room
CTFs. It tasted like at least 50-60 points to me, even given the fuckups for a
few of the tasks.
</p>
</div>
</div>

<div id="outline-container-org45269d6" class="outline-3">
<h3 id="org45269d6">Chloe</h3>
<div class="outline-text-3" id="text-org45269d6">
<p>
(Aside: both this and <i>Coffeehouse</i> were coded in a certain style that I dislike. It seems
by a Python 2 programmer that&rsquo;s afraid of using anything but the trusty old
<code>str</code> datatype, and insists on using them as if they were <code>bytes</code>. This
programmer also enjoys converting X-bit numbers to text strings of &ldquo;0&rdquo; and &ldquo;1&rdquo;
to do binary operations as if working with actual numbers is a bit scary.)
</p>

<p>
So <i>Chloe</i> involved a fair bit of &ldquo;reversing&rdquo; the bad code to get data into
types that are actually sane.
</p>

<p>
What you get is <code>cipher + byte(r)*16</code> (48 bytes) xored with a 16-byte <code>key</code>. <code>r</code>
is a random byte.
</p>

<p>
So modulo an 8-bit brute force, <code>key</code> (originally from <code>os.urandom</code>) is already
given in the last 16 bytes of the output.
</p>

<p>
Now for <code>cipher</code> which is calculated in some Feistel-like manner with an added
permutation at the end:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">R</span> = flag[:<span style="color: #da8548; font-weight: bold;">8</span>],flag[<span style="color: #da8548; font-weight: bold;">8</span>:]

<span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">16</span>):
  <span style="color: #dcaeea;">L</span>,<span style="color: #dcaeea;">R</span> = R, L ^ R ^ roundKey[i] ^ (<span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">64</span>-<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #51afef;">if</span> i%<span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #51afef;">else</span> <span style="color: #da8548; font-weight: bold;">0</span>)

<span style="color: #dcaeea;">cipher</span> = permute(L + R)
</pre>
</div>

<p>
The Feistel function is just a simple xor and predictable negation, so the whole
&ldquo;Feistel network&rdquo; is easily collapsible, as you can simply check the xor keys
that end up being used in left and right side:
</p>

<div class="org-src-container">
<pre class="src src-python">  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">precalculate: (the magic numbers are a[i] = a[i-1]^a[i-2]^2**(i-1) starting</span>
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">from [0,1])</span>
  <span style="color: #dcaeea;">xorL</span> = <span style="color: #c678dd;">reduce</span>(op.xor, [roundKey[i] <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> bits_by_idx(<span style="color: #da8548; font-weight: bold;">14043</span>)])
  <span style="color: #dcaeea;">xorR</span> = <span style="color: #c678dd;">reduce</span>(op.xor, [roundKey[i] <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> bits_by_idx(<span style="color: #da8548; font-weight: bold;">28086</span>)])

  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">and the above Feistel-loop simply collapses to:</span>
  <span style="color: #dcaeea;">cipher</span> = permute(flag ^ (xorL &lt;&lt; <span style="color: #da8548; font-weight: bold;">64</span>) ^ xorR)
</pre>
</div>

<p>
The <code>roundKey</code> array is given by the <code>key</code> found earlier.
</p>

<p>
The last <code>permute()</code> step here performs a fixed random permutation on the bits
in each byte. There&rsquo;s only \(8!\) such permutations so finding the reverse one is
also easily brutable (~15-16 bits). To brute force the permutation I just
did it the simple thing by turning each permutation into a 256-byte translation
table, so I could simply do <code>cipher.translate(Pinv[i])</code> to test a permutation.
</p>

<p>
So: cycle through the bytes, reverse permutation, and do a simple xor and check
if it gives flag data.
</p>
</div>
</div>

<div id="outline-container-orgb03e139" class="outline-3">
<h3 id="orgb03e139">Coffeehouse (cafe house)</h3>
<div class="outline-text-3" id="text-orgb03e139">
<p>
A 32-bit block-cipher which uses a xor, add, and shift in a loop for diffusion.
I.e. it takes the flag and encrypts 4-byte blocks by looping over the block 32
times and doing various add-and-xor-shift with the key and a counter.
</p>

<p>
I really wish the cipher wasn&rsquo;t 32-bits because it&rsquo;s just too tempting to brute
force&#x2026;
</p>

<p>
You only get the encrypted flag as data, so I guess that&rsquo;s clue #1 that at least
a <i>partial</i> brute-force was expected. You guess that no utf-8 is used in the
flag so there&rsquo;s N bits that you know were 0 in the plaintext, and from there you
can filter keys by writing the trivial <code>decrypt()</code> function which was missing.
Technically this dumb way ends up being around 37-bit(?) brute force.
</p>

<p>
This is what I did and I&rsquo;m not particularly proud of it. My program (C++) found
the solution in seconds, but a numpy equivalent with parallel keys would
probably not be much slower.
</p>

<p>
My guess is that maybe the task author <i>intended</i> you to find some way to
strength-reduce the loop? Hmmm. Like, what if it was 64-bit or 128-bit instead?
Or the inner loop had several orders of magnitude more rounds? Then one would
have to solve it by finding invariants&#x2026; And suddenly it&rsquo;s a much cooler
task&#x2013;given that there <i>is</i> a solution to these strengthened problems. I don&rsquo;t
really know, I didn&rsquo;t look into it, I just did the bad thing and moved on. But
my intuition tells me that the diffusion step is really weak and there&rsquo;s plenty
of invariants to be found, so I wouldn&rsquo;t have complained if I was forced to look
into it more, forced to not be lazy. (Again, given that there actually is a
solution?)
</p>
</div>
</div>

<div id="outline-container-orgac1e4c4" class="outline-3">
<h3 id="orgac1e4c4">congruence</h3>
<div class="outline-text-3" id="text-orgac1e4c4">
<p>
I spent the better half of Saturday evening looking at this task. Spoiler: I
didn&rsquo;t solve it. (I don&rsquo;t think anyone did? I think many people were in the same
boat as me, spent a lot of time on it, and maybe ended up frustrated?)
</p>

<p>
It seemed magical, a promise of real beauty! So simple, so clean, pure
mathematics, yet I had no idea how to solve it. That&rsquo;s the best kind of feeling,
isn&rsquo;t it? When you feel stupid because of <i>math</i>. It drew me in immediately.
</p>

<p>
Secrets: \(flag\), \(p\) (a fixed prime modulus of length ~512 bits), and \(s\)
(presumably a very small non-negative integer).
</p>

<p>
You&rsquo;re given five different pairs of numbers \(\lfloor a_{i} / 256 \rfloor\) and
\(c_{i} = a_{i}^e \pmod p\). Each of the numbers \(a_{i}\) are constructed from
ostensibly random alphanumeric bytestring of the same length as flag. You&rsquo;re
also given \(flag^e \pmod p\). So far so good. The coup-de-grâce is the exponent:
\(e = 7 \cdot 37 \cdot 191 \cdot 337 \cdot 31337 \cdot 2^s\).
</p>

<p>
Hmmm&#x2026;? The usual Euler hack of finding \(p\) from \(p\cdot k = gcd(a_i^e -
c_i, a_j^e - c_j)\) (for some small \(k\)) doesn&rsquo;t work because \(e\) is too large,
even if \(s = 0\). The numbers involved would be hundreds of gigabytes. Oh my!
</p>

<p>
The fact that the \(a_{i}\) numbers get their last byte censored seems to indicate
that a solution has to be easily calculable, because the task will
necessarily(?) involve a small brute-force step to test a given solution.
</p>

<p>
So, some ideas I went over:
</p>

<ul class="org-ul">
<li>is there some way to calculate <code>remainder(a^e, b^e - c)</code> iteratively, without
fully reifying the numbers involved?</li>
<li>sub-question: is there some way to calculate the remainder or gcd directly
from vectors of residues modulo sane primes? Prime-factor FFT?</li>
<li>can continued fractions be used somehow, as continued fractions and gcd are
very similar algorithms.</li>
<li>can some clever algebra be used to relieve \(e\) of some of its odd exponents? In
particular: has \(p\) been carefully picked to be revealed in one of the
low-term expansions of some \(a^e - b^e\) expression?</li>
<li>is \(p\) of a special form? E.g. does \(e\) divide into \(p-1\) giving a
power-of-two quotient? (I can&rsquo;t recall if I even tested these last two,
because it would have made the task ugly and idiotic; I didn&rsquo;t want it to be
idiotic, I really wanted to preserve the task&rsquo;s beauty.)</li>
<li>in the relations \(a_i^e - c_i = k_i\cdot p\), we <i>can</i> recover \(k_i\cdot p
  \pmod q\) for saner numbers \(q\) (in particular we can find small factors of
\(k_i\)), but how does that help? All the \(k_i\) integers are too big to actually
be used or reconstructed.</li>
<li>is the special form of the \(a_i\) numbers relevant?</li>
<li>the \(a_i\) plaintext numbers are <i>ostensibly</i> random, but are they really?
Could a seed have been fixed such that it can be used to reveal \(p\) or \(flag\)
in a manner ordinarily impossible? Hmm, unlikely, right?</li>
<li>does it help to find vectors (e.g. LLL) combining the given terms to 0?</li>
</ul>

<p>
Most of these avenues I never really tested. What kept stopping me was the brute
force step on the \(a_i\) terms: I felt I had to be damn sure about an
implementation lest I waste a lot of time, something I could actually verify
before brute-forcing.
</p>

<p>
So I ended up really disliking the brute force step added to this task actually.
(Unless it wasn&rsquo;t intended as a brute-force step, but some kind of magic
fairy-land lattice problem? I don&rsquo;t see how that&rsquo;s possible, though?) It seemed
unnecessary. I also don&rsquo;t know why \(s\) was hidden as well, that just seemed
<i>overly</i> sadistic.
</p>

<p>
But in the end I never really became sure of anything. If there <i>is</i> a solution,
I would be very happy if someone could enlighten me! So far my best intuition is
in the direction of some novel FFT application?
</p>
</div>
</div>

<div id="outline-container-orged5f8cc" class="outline-3">
<h3 id="orged5f8cc">Trio couleurs</h3>
<div class="outline-text-3" id="text-orged5f8cc">
<p>
Spoiler: I didn&rsquo;t solve this one either, but noting my thoughts.
</p>

<p>
I think this task was released during the day on Saturday. The server instantly
disconnected you at first, so I ignored it for a while, and only came back to it
when I finally gave up on <i>congruence</i> above. By then it was late and I found
that this was a really work-intensive task&#x2026;
</p>

<p>
(Again this style of converting numbers to text strings of &ldquo;0&rdquo; and &ldquo;1&rdquo;, so I
take it it&rsquo;s the same task author as <i>Chloe</i> and <i>Coffeehouse</i>, who does seem to
have a particular phobia.)
</p>

<p>
Code is given which looks like DES, used in some broken 3DES-ish manner. It
didn&rsquo;t encrypt the same as a reference DES implementation, so then I have to
waste time to figure out the difference. Turns out it was regular DES reduced to
8 rounds. (Unless this kind of debugging is relevant for the task, I wish the
task made these things clearer, and simply stated sincerely that it was &ldquo;DES
reduced to 8 rounds&rdquo; or similar.)
</p>

<p>
But OK, so it seemed like a linear cryptoanalysis task. The 3DES part of the
task is broken since it trivially leaks the penultimate ciphertext.
</p>

<p>
It doesn&rsquo;t actually seem like a bad task, it&rsquo;s &ldquo;true&rdquo; crypto, though I believe
it requires some prior experience to be doable in hours as opposed to days. Key
discovery from 8-round DES is, as far as I know, not trivial, and require a lot
of plaintexts. I haven&rsquo;t done it before, nor do I have any linear analysis code,
so this contributed to my decision to skip the task, as it would potentially be
a big time sink, I needed sleep, and not many hours remained of the CTF.
</p>

<p>
It&rsquo;s something I could have fun solving off-line though.
</p>
</div>
</div>

<div id="outline-container-org686b3ce" class="outline-3">
<h3 id="org686b3ce">Baby MD5</h3>
<div class="outline-text-3" id="text-org686b3ce">
<p>
I&rsquo;m embarrassed to admit I also wasted a long time staring at this stupid task
doing exactly what the task encouraged me not to do: overthink it. I wrote a
script to solve ASIS&rsquo; proof-of-work using all available cores to make reconnects
fast, and I tried to sample the parameters to see if it would sometimes give \(n
= m\) in which case you can make an MD5 collision and&#x2026; Well, I suppose this was
the &ldquo;trap&rdquo; set up to trick idiots like me.
</p>

<p>
While I was doing this, <code>poiko</code> came along and remarked &ldquo;hm, isn&rsquo;t &lsquo;dead&rsquo; hex,
though? Couldn&rsquo;t you&#x2013;&rdquo; and I instantly cringed and facepalmed pretty hard.
Yeah, indeed&#x2026; Dumb, dumb, dumb.
</p>

<p>
Connect, assert that \(m > n\) and then find a string <code>X</code> such that iterating the
function <code>lambda x: md5(x.encode()).hexdigest()</code> starting with <code>prefix + X</code>
produces a hex string that starts with <code>dead</code> after \(m - n\) iterations; that hex
string is the second input. Could also do this trick for \(m < n\) if the random
prefix turns out to be (lowercase) hex.
</p>
</div>
</div>

<div id="outline-container-org1d0da57" class="outline-3">
<h3 id="org1d0da57">גל התקפה (Attack Wave)</h3>
<div class="outline-text-3" id="text-org1d0da57">
<p>
I solved this one while taking a break from <a href="#orgac1e4c4">congruence</a> above.
</p>

<p>
The boring part: 5.1 WAV file, two channels was a synthetic voice saying what
sounded like &ldquo;RGBA&rdquo; and the other 4 channels contained random noise. The noise
data were all in <code>[0,255]</code> so I extracted that, treated is as image data, and
that&rsquo;s where the fun<sup><a id="fnr.18" class="footref" href="#fn.18" role="doc-backlink">18</a></sup> begins.
</p>

<p>
It&rsquo;s what I like to call a &ldquo;numpy massaging&rdquo; task. In my mind these tasks exists
in a grey area between the guessy and the mathematical<sup><a id="fnr.19" class="footref" href="#fn.19" role="doc-backlink">19</a></sup>. You don&rsquo;t have
the source, you don&rsquo;t know what the task authors did or their reasons for doing
it, so in that sense it&rsquo;s guessy, but what you do have is pure, cold data and
with data you can &ldquo;use the force, Luke.&rdquo; There are certain intuitions to follow
in seeking low entropy, seeking order in the chaos. As long as you&rsquo;re given some
breadcrumb trail of patterns to start with, it&rsquo;s usually fine.
</p>

<p>
For example, displaying the byte data as images of whatever dimension shows
semi-repeated patterns on the top and bottom (low entropy), whereas the
middle of the image appeared much more random (high entropy), which makes it
&ldquo;feel&rdquo; like an image with maybe uniform coloring around the edge with text in
the center, like this:
</p>


<div id="orga0a6f42" class="figure">
<p><img src="./data1.png" alt="data1.png" />
</p>
</div>

<p>
Now we seek to lower this entropy with various basic operations. Xoring all the
channels together direct only increases the entropy, but I noticed that the
three &ldquo;RGB&rdquo; channels were very similar (whereas the &ldquo;A&rdquo; channel was more
chaotic). Looking at the differential of where certain numbers or bits occur is
a good way to get a feel for the repeated patterns. They start out with this
very cyclic pattern, but each is offset a little. So, rotating the arrays to by
small offsets aligns them to produce <i>very</i> low-entropy patterns, differing in
very few bits, so you know you&rsquo;re closer. I combined this trick with the more
mysterious &ldquo;A&rdquo; layer as well, and combining &ldquo;A&rdquo; with any of the other channels
(or all three) quickly produced an image with the flag clearly readable:
</p>


<div id="org2fe755d" class="figure">
<p><img src="./data2.png" alt="data2.png" />
</p>
</div>

<p>
Unfortunately I have no idea what the author&rsquo;s intent was. From the periodic
artifacts still present in the above image, my guess is that there was indeed
some &ldquo;intended&rdquo; way where you get an actual clean image, possibly with the
letters all black and clearly defined. If I were to guess further it might have
something to do with the fact that the data size makes it feel like there&rsquo;s a
row/column missing from the image, that the data given is actually just
differentials between the pixels&#x2026; But I didn&rsquo;t investigate further after I got
the flag. It was a fairly quick task.
</p>
</div>
</div>

<div id="outline-container-orge325775" class="outline-3">
<h3 id="orge325775">Election &amp; Galiver</h3>
<div class="outline-text-3" id="text-orge325775">
<p>
I don&rsquo;t exactly know when these tasks were released, but I didn&rsquo;t see them until
I joined up on Sunday, with like 4-5 hours left of the CTF. Oof.
</p>

<p>
Why, oh why, do most CTFs insist on these staggered releases? Every damn time.
Is it intended to &ldquo;keep things exciting&rdquo; in the competitive sense until the very
end? Because I don&rsquo;t think it&rsquo;s working<sup><a id="fnr.20" class="footref" href="#fn.20" role="doc-backlink">20</a></sup>.
</p>

<p>
<i>Galiver</i> looked cool, seemed to be DH with gaussian integers, but I made the
terrible choice of focusing on the PPC task <i>Election</i> instead because it
&ldquo;seemed easy.&rdquo;
</p>

<p>
Then I invested too much into <i>Election</i> and I was sunk by my own sunk-cost
fallacy. The cherry on top was that this task was actually bugged server-side.
</p>

<p>
<i>Election</i> was a PPC where you are given a string of base-10 digits and have to
give some binary arithmetic expression like <code>X op Y</code> (where <code>op</code> can be one of
<code>{+,-,*,/,**}</code>) in which these digits can be found as a substring. The
expression you give cannot be more than 8 characters long. You can also just
enter a single number so for levels up to strings of length 8, you can just feed
it back the string given granted it doesn&rsquo;t start with a 0.
</p>

<p>
Each level the base-10 string you get has length +1. It has an unknown number of
levels, which is the first guessy part, because at first you don&rsquo;t really know
what you&rsquo;re up against. Making a small in-memory database of the shorter
expressions and their digits gets you to length 12+ strings and you realize
you&rsquo;ll need to make a full database of all strings producible by these
arithmetic expressions. I dumped these to external files and just used <code>grep</code> in
my solve-script. These files were several gigabytes each.
</p>

<p>
The addition, subtraction, and multiplications are trivial and can be ignored.
</p>

<p>
All the guessy elements stem from the <i>server-side code being hidden</i>. That&rsquo;s
<i>always</i> a bad sign. First you have to assume (pray) that it actually picks
<i>valid</i> substrings. OK, fine, I&rsquo;ll allow it, but it doesn&rsquo;t feel <i>great</i> to
trust the author like this, especially when knowing that the author is merely
human, and the code might not have been tested by others.
</p>

<p>
The exponentiation expressions are the simplest to dump, but most time-consuming
in CPU time (<code>gmpy2</code> and not Python&rsquo;s slow bigints), so I started with those.
Constructing the database of digit expansions from the divisions are the more
brain-intensive and tricky if you want to do it &ldquo;properly.&rdquo; From some pen and
paper and Wikipedia I re-figured the repetend in the expansion of, for example,
<code>a/b</code> is of length \(k\) where \(k\) is the least number such that \(10^k = 1 (mod
b)\). Thus for prime \(b\) it will be up to \(b-1\) digits &#x2013; so I figured this part
of the database migth require a magnitude more disk space, because the numbers
involved are larger (<code>D**DDDDD</code> vs <code>D/DDDDDD</code>), and thus wanted to take some
extra care to only store what is necessary. I knew that for the cyclic numbers
the numerator can be fixed to 1, but it was unclear to me whether \(a/b\) for
composite numbers could give new &ldquo;unique&rdquo; decimal sequences. I don&rsquo;t have that
much SSD disk space&#x2026;
</p>

<p>
But bottom line: expressions on the form <code>D/DDDDDD</code> can give <i>up to</i>
\(999999+\epsilon\) digits before repeating. And this is where the server-side bug
comes in. As my database kept filling up I started encountering this:
</p>

<pre class="example" id="org87b055b">
[DEBUG] Sent 0x9 bytes: b'1/102451\n'
[DEBUG] Received 0x60 bytes: b'sorry, the result of your expression does not contain the given substr: 07718811919\n'
</pre>

<p>
Yet:
</p>

<pre class="example" id="org9a1ddce">
&gt;&gt;&gt; getcontext().prec = 200000
&gt;&gt;&gt; '07718811919' in str(Decimal(1)/102451)
True
</pre>

<p>
Hmmm. I kept getting more and more of these errors, barring me from further
levels. I didn&rsquo;t really know what was going wrong. I thought maybe I had a bug
somewhere making it skip certain &ldquo;easy&rdquo; expressions and giving the server
fractions it didn&rsquo;t expect (like if the server erroneously expected some fixed
low-term expression for the later levels). It felt really bad to be in the dark.
Finally I went on IRC and tried to contact admin. It turned out the server
actually only calculates fractions to <code>99999</code> digits:
</p>

<pre class="example" id="orgee5058d">
[...]
15:56 &lt;factoreal&gt; see this:
15:56 &lt;factoreal&gt; if len(formula) &lt;= 8:
15:56 &lt;factoreal&gt; IIif re.match(regex, formula):
15:56 &lt;factoreal&gt; IIItry:
15:56 &lt;factoreal&gt; IIIIif '/' in formula:
15:56 &lt;factoreal&gt; IIIIIa, b = formula.split('/')
15:56 &lt;factoreal&gt; IIIIIres = mpfr(Fraction(int(a), int(b)), 99999)
15:56 &lt;factoreal&gt; IIIIelse:
15:56 &lt;factoreal&gt; IIIIIres = eval(formula)
15:56 &lt;factoreal&gt; IIIIif substr in str(res):
15:56 &lt;factoreal&gt; IIIIIreturn True
15:57 &lt;franksh&gt; hm, yeah, so bugged. :/ 99999 isn't enough to cover all repetends/decimal expansions of some fractions.
15:58 &lt;franksh&gt; but i didn't find a way to get or see server source?
15:59 &lt;factoreal&gt; the cycle of 1/p where p is prime is p-1
15:59 &lt;factoreal&gt; franksh I will share it after CTF, ok?
16:00 &lt;franksh&gt; yeah, but 6-digit numbers are valid in d/dddddd so need an order of magnitude more to cover all
16:00 &lt;franksh&gt; and sure
16:01 &lt;factoreal&gt; you are right
</pre>

<p>
The classic off-by-one-order-of-magnitude bug. But by then, as is shown by the
timestamps above (CTF ended 16:00 for me), it was too late to do anything. That
felt pretty shitty, and a sour note to end it on.
</p>

<p>
From IRC, I think the one solver of this task said something about only
searching fractions <code>1/p</code> with (fixed) 30000 precision(?), which seemed like
pure luck (or they&rsquo;re just a very good guesser). That also gives a clue to a
<i>third</i> problem with the task, in that it didn&rsquo;t select the base-10 strings
randomly at all. You could &ldquo;guess&rdquo; that exponentiation was irrelevant, and only
search <code>1/p</code> up to 100000 in an on-line fashion? Urk.
</p>

<p>
Pretty disappointing. Should probably have done <i>Galiver</i> instead. Oh well,
offline I guess.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb33efe6" class="outline-2">
<h2 id="orgb33efe6">JustCTF 2020</h2>
<div class="outline-text-2" id="text-orgb33efe6">
</div>
<div id="outline-container-justctf2020" class="outline-3">
<h3 id="justctf2020">General Comments</h3>
<div class="outline-text-3" id="text-justctf2020">
<p>
Back for another CTF after Christmas depression.
</p>

<p>
(CTF apparently called 2020 because it was rescheduled even though it took place in 2021.)
</p>

<p>
Overall seemed like an okay mid-tier CTF. &ldquo;Decent, but not great.&rdquo; The
tasks I looked at were a bit on the easy side, there were only two
crypto, one of them very meh, and pretty much all of the misc was
meh-adjacent.
</p>

<p>
I only actively played the first day (Saturday) so can&rsquo;t really say
that much about the tasks released late<sup><a id="fnr.21" class="footref" href="#fn.21" role="doc-backlink">21</a></sup>.
</p>

<p>
Also, one complaint <code>poiko</code> had that I fully agree with and can
forward: all flags outputted by tasks should be <i>consistent</i>. (C.f.
<code>reklest</code>.) It&rsquo;s such a basic thing it should be considered a cardinal
sin to violate it. If the nature of a task <i>requires</i> a different
format, there should be a big note describing it in mathematically
precise English. (C.f. the convoluted description on <code>ABNF</code>.)
</p>
</div>
</div>

<div id="outline-container-orgb61a1d9" class="outline-3">
<h3 id="orgb61a1d9">25519</h3>
<div class="outline-text-3" id="text-orgb61a1d9">
<p>
Trivial crypto task where you get the private key. The hardest part is
simply to mentally parse the script to see what it expects.
</p>

<p>
The goal is to pass this check with 8 different parameter sets:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">verify</span>(signature, P, m):
  <span style="color: #dcaeea;">I</span>, <span style="color: #dcaeea;">e</span>, <span style="color: #dcaeea;">s</span> = signature
  <span style="color: #51afef;">return</span> e == hashs(m, s*G + e*P, s*hashp(P) + e*I)
</pre>
</div>

<p>
You provide <code>I, e, s</code> and you&rsquo;re given everything else: <code>P, m, G, x</code>,
where \(x\) is the private key in \(P = x G\). <code>hashp(P)</code> can be treated
as a new random point on the curve.
</p>

<p>
Thus, to generate however many solutions you want:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dcaeea;">x</span> = ... <span style="color: #5B6268;"># </span><span style="color: #5B6268;">the given private key, P=xG</span>
<span style="color: #dcaeea;">Q</span> = hashp(P) <span style="color: #5B6268;"># </span><span style="color: #5B6268;">treat hashp(P) as a novel point</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">random nonces</span>
<span style="color: #dcaeea;">t</span> = &lt;random&gt;
<span style="color: #dcaeea;">h</span> = &lt;random&gt;

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">the target hash that we will construct</span>
<span style="color: #dcaeea;">e</span> = hashs(m, t*G, h*Q)

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">set s such that t*G == s*G + e*P</span>
<span style="color: #dcaeea;">s</span> = (t - e*x) % ec_order

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">set I such that h*Q == s*Q + e*I</span>
<span style="color: #dcaeea;">I</span> = (h - s) * <span style="color: #c678dd;">pow</span>(e, -<span style="color: #da8548; font-weight: bold;">1</span>, ec_order) * Q

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">e, s, I is a solution</span>
</pre>
</div>

<p>
Do this 8 times and get the flag.
</p>
</div>
</div>
<div id="outline-container-org6f65768" class="outline-3">
<h3 id="org6f65768">Oracles</h3>
<div class="outline-text-3" id="text-org6f65768">
<p>
Web-ish crypto where you&rsquo;re given the code for a nodejs server. (Whose
instances are gated behind a 28-bit PoW.)
</p>

<p>
It vaguely involved a quadfecta of things I dislike (web, javascript,
remote, docker), so I dragged my feet a lot before I was bribed with
pizza to properly look at it.
</p>

<p>
But so: the instance gives you three ciphertexts, two being of known
plaintexts, the third being the flag. Each is encrypted with
<code>RSA_OAEP</code> from <code>asmcrypto.js</code>.
</p>

<p>
(Note: the first iteration of this problem, and the one I wasted the
most time on had the public key redacted, so you didn&rsquo;t know the
modulus (normal exponent of 65537 was implied). Which I felt was
pretty sadistic and painful. I realize you could technically recover
it from the given ciphertexts, doing GCD on 64MB numbers, but that&rsquo;s
pretty painful&#x2026; (Either reimplement OAEP or use noedjs, probably
need to use a good bigint library like GMP and not Python&rsquo;s slow-ints,
etc.) They later updated the task to provide the pubkey, but they only
noted this on the &ldquo;news&rdquo; page and not on in task description itself so
I totally missed it until <code>poiko</code> pointed it out to me. I feel that&rsquo;s
sort of bad communication.)
</p>

<p>
On the server there&rsquo;s an oracle query that does this:
</p>

<div class="org-src-container">
<pre class="src src-javascript">  <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">oracle</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">asmCrypto.RSA_OAEP</span>(privkey, <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">asmCrypto.Sha256</span>(), fs.readFileSync(<span style="color: #98be65;">'./oracles_stuff/'</span> + oracleName));

  <span style="color: #51afef;">var</span> <span style="color: #dcaeea;">response</span> = <span style="color: #98be65;">'I won\'t answer.'</span>;
  <span style="color: #51afef;">try</span> {
      <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">result</span> = oracle.decrypt(question);
      asmCrypto.bytes_to_string(result);
  } <span style="color: #51afef;">catch</span>(err) {
      <span style="color: #5B6268;">//</span>
  }

  res.render(<span style="color: #98be65;">'index'</span>, {response: response});
</pre>
</div>

<p>
That is, you give it some data, it attempts to decrypt it and simply
discards everything, ignoring errors.
</p>

<p>
It was easy to guess that it would be a timing attack problem, but
because you have to actually do non-trivial stuff (i.e. web) to test
your guess I was still loath to commit.
</p>

<p>
However there were two factors that severely strengthened my guess
that it&rsquo;s a timing attack problem.
</p>

<p>
Inspecting the <code>asmcrypto.js</code> source strengthens the guess tho:
</p>

<div class="org-src-container">
<pre class="src src-javascript">    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">...</span>
    <span style="color: #a9a1e1;">this</span>.rsa.decrypt(<span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">BigNumber</span>(data));

    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">z</span> = <span style="color: #a9a1e1;">this</span>.rsa.result[<span style="color: #da8548; font-weight: bold;">0</span>];
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">seed</span> = <span style="color: #a9a1e1;">this</span>.rsa.result.subarray(<span style="color: #da8548; font-weight: bold;">1</span>, hash_size + <span style="color: #da8548; font-weight: bold;">1</span>);
    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">data_block</span> = <span style="color: #a9a1e1;">this</span>.rsa.result.subarray(hash_size + <span style="color: #da8548; font-weight: bold;">1</span>);

    <span style="color: #51afef;">if</span> (z !== <span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #51afef;">throw</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">SecurityError</span>(<span style="color: #98be65;">'decryption failed'</span>);

    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">seed_mask</span> = <span style="color: #a9a1e1;">this</span>.RSA_MGF1_generate(data_block, seed.length);
    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; seed.length; i++) seed[i] ^= seed_mask[i];

    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">data_block_mask</span> = <span style="color: #a9a1e1;">this</span>.RSA_MGF1_generate(seed, data_block.length);
    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; data_block.length; i++) data_block[i] ^= data_block_mask[i];

    <span style="color: #51afef;">const</span> <span style="color: #dcaeea;">lhash</span> = <span style="color: #a9a1e1;">this</span>.hash
      .reset()
      .process(<span style="color: #a9a1e1;">this</span>.label || <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Uint8Array</span>(<span style="color: #da8548; font-weight: bold;">0</span>))
      .finish().result as Uint8Array;
    <span style="color: #51afef;">for</span> (<span style="color: #51afef;">let</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; hash_size; i++) {
      <span style="color: #51afef;">if</span> (lhash[i] !== data_block[i]) <span style="color: #51afef;">throw</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">SecurityError</span>(<span style="color: #98be65;">'decryption failed'</span>);
    }
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">...</span>
</pre>
</div>

<p>
I.e. it checks immediately if the first byte is 0 and fails early if
not. Only after this check does it hash the label data. And note in
the oracle source you can provide whatever file you want for the
label. (I found the largest file on the docker, which was something
like <code>../../opt/yarn-v1.22.5/lib/cli.js</code> and used that.)
</p>

<p>
Second and final hint that it&rsquo;s a straightforward timing attack: the
server explicitly gives its response-time in the HTTP headers so you
don&rsquo;t actually have to time it yourself.
</p>

<p>
It turns out the difference between a valid decryption and an invalid
one was something like ~7ms vs ~40ms, so yes, now you have a
decryption oracle (on the first byte).
</p>

<p>
From there, finally!, there&rsquo;s actual math. The basic idea is that you
can multiply the message \(m\) by a number \(k\) (because \((m\cdot k)^e =
c\cdot k^e\)) and have the decrypt method tell you whether the first
byte (in big endian) is 0 or not, meaning that \(l\cdot n \le k \cdot m
< l \cdot n + 2^{1024-8}\) for some \(l\). I use this as an invariant.
</p>

<p>
This was all napkin math I did at the time but hopefully correct.
</p>

<p>
Set \(B = 2^{1024-8}\) because we&rsquo;re checking on high 8 bits. First we
need to discover a \(k\) to start with, i.e. where \(l = 1\) in the above
case. This is \(k = \lceil n / m \rceil\). I used \(\lceil n/B \rceil\) as
an estimate and brute force it, even though there&rsquo;s better ways, this
is simpler.
</p>

<p>
The idea is to keep multiplying the values by 2 and readjusting based
on what the oracle tells us. We always want \(k\) (named <code>a</code> in the code
below) to be the least possible so that \(k\cdot m\) &ldquo;barely&rdquo; overflows
on the modulus. When we multiply all values by 2, we then have to
figure out if we&rsquo;re in \([0,B)\) or \([B,2 B)\) based on what the oracle
tells us. Code like so: (comments and cleanup added after-the-fact.)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">discover</span>(n, B, oracle):
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">First discover a = ceil(n//T)</span>

  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Use a more efficient techinque here if (n//B)*T &lt; B</span>
  <span style="color: #51afef;">assert</span> <span style="color: #51afef;">not</span> oracle(n//B)

  <span style="color: #dcaeea;">a</span> = n//B + <span style="color: #da8548; font-weight: bold;">1</span>
  <span style="color: #51afef;">while</span> <span style="color: #51afef;">not</span> oracle(a):
    <span style="color: #dcaeea;">a</span> += <span style="color: #da8548; font-weight: bold;">1</span>

  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">assert a == n//T + 1</span>
  <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> count(<span style="color: #da8548; font-weight: bold;">0</span>):
    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">assert 2**i*n &lt;= a*T &lt; 2**i*n + B</span>

    <span style="color: #51afef;">if</span> B//a == <span style="color: #da8548; font-weight: bold;">0</span>:
      <span style="color: #51afef;">return</span> (<span style="color: #da8548; font-weight: bold;">2</span>**i * n + B)//a

    <span style="color: #dcaeea;">a</span> = <span style="color: #da8548; font-weight: bold;">2</span>*a - <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #51afef;">if</span> <span style="color: #51afef;">not</span> oracle(a):
      <span style="color: #dcaeea;">a</span> += <span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>

<p>
It failed the first time I tried it against the live server, but that
might have been a timing glitch. I didn&rsquo;t have any error detection
stuff in my code, for when the ranges have become invalid. It might be
possible to do something more clever and robust here, but <i>eh, c&rsquo;est
la vie de CTF</i>.
</p>

<p>
So now you have \(m\) and I need to decrypt it with this OAEP nonsense.
I just copy pasted the bytes of \(m\) into an array and used <code>nodejs</code> so
I could apply <code>asmcrypto.js</code> directly by copy-pasting the latter half
of the decrypt function. I didn&rsquo;t really feel like reimplementing
anything or looking up more APIs.
</p>

<p>
All in all I have to admit it&rsquo;s a pretty well-made crypto task from a
certain perspective. If you&rsquo;re the sort of person who cares about
practical applicability and the real world then it&rsquo;s A+. Unfortunately
I&rsquo;m not and kept whining over the fact that I had to actually read js
code.
</p>
</div>
</div>

<div id="outline-container-org0efb280" class="outline-3">
<h3 id="org0efb280">That&rsquo;s not crypto</h3>
<div class="outline-text-3" id="text-org0efb280">
<p>
Listed as reverse so I only discovered it by accident. Python byte
code that contains a list of big numbers. These numbers are used as
coefficients in a polynomial \(P(x)\) and there&rsquo;s a check that does
something like <code>all(c*P(d*x) == c*c for x in accumulate(flag))</code> for
some fixed literals <code>c</code> and <code>d</code>. In other words, the cummulative sums
of flag&rsquo;s bytes are the roots of \(P(x)-c\) divided by \(d\). Instead of
trying to factor this polynomial, I just did this in REPL:
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span style="color: #dcaeea;">n</span> = <span style="color: #51afef;">lambda</span> l: [i <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">256</span>) <span style="color: #51afef;">if</span> p(d*(l + i)) == c][<span style="color: #da8548; font-weight: bold;">0</span>]
&gt;&gt;&gt; <span style="color: #dcaeea;">r</span> = [n(<span style="color: #da8548; font-weight: bold;">0</span>)]
&gt;&gt;&gt; <span style="color: #51afef;">while</span> <span style="color: #a9a1e1;">True</span>: r.append(n(<span style="color: #c678dd;">sum</span>(r)))
</pre>
</div>

<p>
It will stop on exception and then <code>print(bytes(r))</code> gives the flag.
</p>
</div>
</div>

<div id="outline-container-org6e67f8a" class="outline-3">
<h3 id="org6e67f8a">PDF is broken, and so is this file</h3>
<div class="outline-text-3" id="text-org6e67f8a">
<p>
Put off this task till late because I vibed from the description that
it would be some stupid rabbit hole thing. <code>poiko</code> did some
preliminary analysis and told me I was right.
</p>

<p>
The &ldquo;PDF&rdquo; file you get can be intrepreted as a Ruby script; and as
such a script it starts a web server on localhost where you can
download the file itself but now with a .zip extension. I.e. the zip
file is identical to the original file. I have to admit that already
had me going &ldquo;wtf.&rdquo; (It&rsquo;s weird that <code>unzip</code> doesn&rsquo;t even complain,
even though it obivously needs to skip large parts of the file to
reach the zip data stream.) There was also some false(?) hint like
<code>"readelf -p .note might be useful later"</code> that never became relevant
for me.
</p>

<p>
In the zip file there&rsquo;s a meme link to a YouTube video talking about
how stupid these &ldquo;broken PDF&rdquo; tasks are and asking CTFs to please stop
running them, together with a <code>mutool</code> binary for repairing broken
PDFs, and a script to run said command in a docker (should you need
it). Running the command gives a PNG that&rsquo;s full of conspiracy theory
spoofs, references to Tonybee tiles, Frank Chu, and the like, and
other stuff that treads the line between tragic schizophrenia and
memetic mystery. Oh, and also a reference to the &ldquo;it&rsquo;s a trap&rdquo; meme
and something blah blah about PDF bombs.
</p>

<p>
That is when I sort of just bailed out and took a more brute force
approach:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">streams</span>(dat):
  <span style="color: #dcaeea;">j</span> = <span style="color: #da8548; font-weight: bold;">0</span>
  <span style="color: #51afef;">while</span> <span style="color: #a9a1e1;">True</span>:
    <span style="color: #51afef;">try</span>:
      <span style="color: #dcaeea;">i</span> = dat.index(b<span style="color: #98be65;">'\x06stream\x0a'</span>, j)
    <span style="color: #51afef;">except</span> <span style="color: #ECBE7B;">ValueError</span>:
      <span style="color: #51afef;">return</span>
    <span style="color: #dcaeea;">j</span> = dat.index(b<span style="color: #98be65;">'\x0aendstream'</span>, i)
    <span style="color: #51afef;">yield</span> dat[i+<span style="color: #da8548; font-weight: bold;">8</span>:j]
</pre>
</div>

<p>
I.e. I gave up on trying to make <code>challenge.pdf</code> play nice with any
other program and simply extracted the streams in a &ldquo;dumb&rdquo; way, saving
them all as files, deflating those that needed deflating.
</p>

<p>
Here there&rsquo;s various images (the ones rendered in the conspiracy PNG
above), font data, and random stuff like another false(?) hint about
<code>pip install polyfile</code> and so on.
</p>

<p>
But one of the streams has a lot of hex codes listed as text data.
Converting it to binary (it had the JPEG magic bytes) and opening it
gives the flag.
</p>

<p>
I&rsquo;m lowkey impressed by the work that probably went into creating the
task, and of course the memes, but it&rsquo;s still a &ldquo;<a href="https://www.reddit.com/r/TIHI/">thanks, I hate it</a>&rdquo;
sort of thing.
</p>
</div>
</div>
</div>

<div id="outline-container-org5bba4e8" class="outline-2">
<h2 id="org5bba4e8">zer0pts CTF 2021</h2>
<div class="outline-text-2" id="text-org5bba4e8">
</div>
<div id="outline-container-zer0pts2021" class="outline-3">
<h3 id="zer0pts2021">General Comments</h3>
<div class="outline-text-3" id="text-zer0pts2021">
<p>
I don&rsquo;t really have any comments regarding this CTF because I didn&rsquo;t
really play much. I hardly logged in, I was &ldquo;busy&rdquo; and not very
motivated this weekend, but just noting it here in my CTF &ldquo;diary.&rdquo;
</p>

<p>
I know <code>poiko</code> enjoyed it though, so it was probably good.
</p>

<p>
The motivation I <i>did</i> have was mostly to help out because I&rsquo;ve
been a shit team player for a while now, not really finding any
will to li<code>^W</code>play. <code>poiko</code> kept posting tasks to me on Discord and I gave
comments when able.
</p>

<p>
I only looked at the easy tasks. I skipped the two elliptic curve
tasks completely because they weren&rsquo;t immediately obvious to me&#x2013;I
imagine they would involve googling stuff and/or Thinking, which I
wanted to avoid.
</p>
</div>
</div>

<div id="outline-container-org26afe66" class="outline-3">
<h3 id="org26afe66">Easy Pseudo Random</h3>
<div class="outline-text-3" id="text-org26afe66">
<p>
An RNG<sup><a id="fnr.22" class="footref" href="#fn.22" role="doc-backlink">22</a></sup> is set up, \(s_i = s_{i-1}^2 + b \pmod{p}\).
</p>

<p>
You&rsquo;re given the high bits of two consecutive states and the goal is
to reconstruct the stream. So you have \((H_0 \cdot 2^{85} + u)^2 + b =
H_1 \cdot 2^{85} + v\) with \(u, v\) being two unknown &ldquo;small&rdquo; (85 bits)
integers.
</p>

<p>
With high bits anything I immediately think of lattices as the obvious
candidate, so that&rsquo;s what I tried here for a quick solve. I just
ignored the terms \(u^2\) and \(v\) completely, trying to just minimize
the simple and linear expression \(2^{86} H_0 v + b - 2^{85} H_1 \pmod
p\) with a small \(u\). I can 100% guarantee that there&rsquo;s a cleaner and
more robust way to attack the full polynomial, but I&rsquo;m dumb and would have
to Think or google for it which, like I said, I wanted to avoid.
</p>

<p>
The error of the linear equation is expected to be around 170 bits, so
I tried to find short vectors from a matrix like so:
</p>

<div class="org-src-container">
<pre class="src src-python">[[ p+b-(H1&lt;&lt;<span style="color: #da8548; font-weight: bold;">85</span>),     <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>&lt;&lt;K0 ], <span style="color: #5B6268;"># </span><span style="color: #5B6268;">constant term</span>
 [       H0&lt;&lt;<span style="color: #da8548; font-weight: bold;">86</span>, <span style="color: #da8548; font-weight: bold;">1</span>&lt;&lt;K1,     <span style="color: #da8548; font-weight: bold;">0</span> ], <span style="color: #5B6268;"># </span><span style="color: #5B6268;">linear factor of u</span>
 [            p,     <span style="color: #da8548; font-weight: bold;">0</span>,     <span style="color: #da8548; font-weight: bold;">0</span> ]] <span style="color: #5B6268;"># </span><span style="color: #5B6268;">modulus</span>
</pre>
</div>

<p>
Starting with parameters <code>K1 ~ 86</code> and <code>K2 ~ 171</code> that I massaged a
little until the correct solution for \(u\) tumbled out. Was mostly a
quick hack. The rest is trivial.
</p>
</div>
</div>

<div id="outline-container-orge58a3f6" class="outline-3">
<h3 id="orge58a3f6">wa(rsa)mup</h3>
<div class="outline-text-3" id="text-orge58a3f6">
<p>
<code>poiko</code> solved this one because he thought I wasn&rsquo;t going to play. I
was offline most of Friday and early Saturday.
</p>

<p>
I didn&rsquo;t know he had solved it and so I double-solved it. But no
matter, it was a quick/standard problem.
</p>

<p>
Standard RSA setup. There&rsquo;s some code noise around padding but it&rsquo;s
irrelevant. The immediate suspect thing is you&rsquo;re given two
ciphertexts: \(c_0 = m^e \pmod n\) and \(c_1 = {\lfloor \frac{m}{2}
\rfloor}^e \pmod n\). Because the message \(m\) (probably) ends with <code>}</code>
it is (probably) odd, which is relevant because now we have a
non-trivial relation \(m_0 = 2 m_1 + 1\). (If the relation had been \(m_0
= 2 m_1\) instead, it wouldn&rsquo;t provide us with any more information.)
</p>

<p>
Plugging this relation into the ciphertext equations and treating the
message as an &ldquo;unknown&rdquo; we have two polynomial expressions which both
have the message as a root and we can take their gcd:
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span style="color: #dcaeea;">g</span> = (x**e-c1).gcd(((x-<span style="color: #da8548; font-weight: bold;">1</span>)/<span style="color: #da8548; font-weight: bold;">2</span>)**e - c2)
&gt;&gt;&gt; g
[<span style="color: #da8548; font-weight: bold;">113128245622357901252722513691018597529212818374857225068412230803117273431764336733611386199949429353010088688478215740193848150958821139378543874939689746528140403143114943900235798243884022251713648885768664407134358754271963457290992686093387882808160942022485994772070150575070443505280922344644888038580</span> <span style="color: #da8548; font-weight: bold;">1</span>]
&gt;&gt;&gt; (-g[<span style="color: #da8548; font-weight: bold;">0</span>]).lift().<span style="color: #c678dd;">bytes</span>()
b<span style="color: #98be65;">'\x02\x81\xae\xed \xdd\x07\x12;\x99\xc7d:\x99\x1a8\x16\xfe\xe6&lt;\x18\x1dw\xea&amp;\xfb\xfc\x8a\xa7\xa8\xba\xfa\xd8\xbe\xdf\x01\x13\xcb\xd3\x99\x9c\xf3_\x18qw\xb99}\'Q\xd7~\x03&amp;^\xcd\x9aw\xf0\xef\xb5\x04\x1b\xb7\n\xe1\xcd"\x95ff]\x0c(H\x99\xb5\xed\xc3\x82\x9dl\xe4\x8c\xddx\xfd\x00zer0pts{y0u_g07_47_13457_0v3r_1_p0in7}'</span>
</pre>
</div>

<p>
(Here using some number theory wrappers (using NTL) that I wrote for
regular Python so I didn&rsquo;t have to use Sage so much. A leap for a man,
an insignificant stumble for mankind.)
</p>
</div>
</div>

<div id="outline-container-orgcabd6e6" class="outline-3">
<h3 id="orgcabd6e6">janken vs. yoshiking</h3>
<div class="outline-text-3" id="text-orgcabd6e6">
<p>
Didn&rsquo;t really solve it so much as I just told <code>poiko</code> my guess for the
solution after seeing it. He wrote the actual solution.
</p>

<p>
What I wrote on Discord + added corrections:
</p>

<div class="org-src-container">
<pre class="src src-python">
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">assumption: secret key x is odd.</span>
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">re-run program until x is odd</span>

  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">idea, match quadratic "residue-ness" of numbers to rule out</span>
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">possibilities.</span>

  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">put the numbers in GF(p) &#229;ker etc.</span>

  <span style="color: #dcaeea;">c0sq</span> = c0.is_square()
  <span style="color: #dcaeea;">canbe</span> = <span style="color: #da8548; font-weight: bold;">7</span> <span style="color: #5B6268;"># </span><span style="color: #5B6268;">1|2|4 == all</span>
  <span style="color: #51afef;">if</span> c0sq != c1.is_square():
      <span style="color: #dcaeea;">canbe</span> ^= <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #5B6268;"># </span><span style="color: #5B6268;">can't be rock</span>
  <span style="color: #51afef;">if</span> c0sq != (c1/<span style="color: #da8548; font-weight: bold;">2</span>).is_square():
      <span style="color: #dcaeea;">canbe</span> ^= <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #5B6268;"># </span><span style="color: #5B6268;">can't be scissors</span>
  <span style="color: #51afef;">if</span> c0sq != (c1/<span style="color: #da8548; font-weight: bold;">3</span>).is_square():
      <span style="color: #dcaeea;">canbe</span> ^= <span style="color: #da8548; font-weight: bold;">4</span> <span style="color: #5B6268;"># </span><span style="color: #5B6268;">can't be paper</span>

  <span style="color: #dcaeea;">choice</span> = [<span style="color: #98be65;">'invalid'</span>,
    <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #5B6268;"># </span><span style="color: #5B6268;">beat rock</span>
    <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #5B6268;"># </span><span style="color: #5B6268;">beat scissors</span>
    <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #5B6268;"># </span><span style="color: #5B6268;">50-50 to win/draw</span>
    <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #5B6268;"># </span><span style="color: #5B6268;">beat paper</span>
    <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #5B6268;"># </span><span style="color: #5B6268;">50-50</span>
    <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #5B6268;"># </span><span style="color: #5B6268;">50-50</span>
    randint(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">3</span>), <span style="color: #5B6268;"># </span><span style="color: #5B6268;">???</span>
    ][canbe]

</pre>
</div>

<p>
Which apparently worked.
</p>

<p>
This was probably the best (as in &ldquo;non-boring&rdquo;) task of the ones I
looked at.
</p>
</div>
</div>

<div id="outline-container-orgd6f81aa" class="outline-3">
<h3 id="orgd6f81aa">ot or not ot</h3>
<div class="outline-text-3" id="text-orgd6f81aa">
<p>
This one too, I didn&rsquo;t actually write the code or interact with the
server, I just wrote on Discord what I thought the solution would be:
</p>

<div class="org-src-container">
<pre class="src src-python">
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">reasoning:</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">X = bit0 ^ ( a^r * c^s )</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Y = bit1 ^ ( b^r * c^s )</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Z =        ( d^r * t^s )</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">a = 2 or whatever</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">b = a^-1</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">c = -1</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">X*Y = (-1)^(2*s) = 1</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">send:</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">a = 2 or whatever</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">b = pow(a, -1, p)</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">c = -1 % p</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">d = ??? doesn't matter?</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">then get x,y (z doesn't matter???) and this should work:</span>

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">get_two_bits</span>(X,Y):
  <span style="color: #51afef;">for</span> bit0, bit1 <span style="color: #51afef;">in</span> product((<span style="color: #da8548; font-weight: bold;">0</span>,<span style="color: #da8548; font-weight: bold;">1</span>), (<span style="color: #da8548; font-weight: bold;">0</span>,<span style="color: #da8548; font-weight: bold;">1</span>)):
    <span style="color: #51afef;">if</span> (X^bit0)*(Y^bit1)%p == <span style="color: #da8548; font-weight: bold;">1</span>:
      <span style="color: #51afef;">return</span> bit0 + <span style="color: #da8548; font-weight: bold;">2</span>*bit1

</pre>
</div>

<p>
Which it did. I don&rsquo;t really understand what the <code>d</code>, <code>t</code> and <code>z</code>
variables were doing in the program, they seemed completely
superfluous? Perhaps the problem author had overlooked the possibility of
giving <code>-1</code> for <code>c</code> so that \(c^k\) becomes a trivial factor?
</p>
</div>
</div>

<div id="outline-container-orgaefc0d3" class="outline-3">
<h3 id="orgaefc0d3">Triple AES</h3>
<div class="outline-text-3" id="text-orgaefc0d3">
<p>
This was the last task I did because it took much longer than the
others (hours vs minutes), and so felt I was getting &ldquo;sucked in.&rdquo;
</p>

<p>
Setup: you can decrypt/encrypt arbitrary messages with some cipher
that chains three AES instances (different keys) working in different
block modes (ECB, CBC, CFB). You don&rsquo;t control the IVs generated for
encryptions. You&rsquo;re disconnected immediately when retrieving the
encrypted flag.
</p>

<p>
Not very hard, but very fiddly and ugh. These are my notes from the
comments (I tend to &ldquo;work out&rdquo; my thinking in comments):
</p>

<div class="org-src-container">
<pre class="src src-python">
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">encryption:</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">PLAIN: m0 || m1</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">ECB: E0(m0) || E0(m1)</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">CBC: E1(iv0 + E0(m0)) || E1( E1(iv0 + E0(m0)) + E0(m1) )</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">CFB: E2(iv1) + E1(iv0 + E0(m0)) || E2(E2(iv1) + E1(iv0 + E0(m0))) + E1( E1(iv0 + E0(m0)) + E0(m1) )</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">decryption:</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">PLAIN: c0 || c1</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">CFB: E2(iv1) + c0 || E2(c0) + c1</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">CBC: D1(E2(iv1) + c0) + iv0 || D1(E2(c0) + c1) + E2(iv1) + c0</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">ECB: D0(D1(E2(iv1) + c0) + iv0) || D0(D1(E2(c0) + c1) + E2(iv1) + c0)</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">dec(0) : D0( D1(E2(0)) ) || D0( D1(E2(0)) + E2(0) )</span>
<span style="color: #5B6268;">#        </span><span style="color: #5B6268;">: D0(D1( E20 )) || D0( D1(E20) + E20 )</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">enc(0) : E2(R1) + E1(R0 + E0(0)) || E2(E2(R1) + E1(R0 + E0(0))) + E1(E1(R0 + E0(0)) + E1(0))</span>
<span style="color: #5B6268;">#        </span><span style="color: #5B6268;">: E2(R1) + E1(R0 + E00) || E2( E2(R1) + E1(R0 + E00) ) + E1( E1(R0 + E00) + E10 )</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">dec0(enc0,iv1=R1,iv0=0) :</span>
<span style="color: #5B6268;">#   </span><span style="color: #5B6268;">D0( R0 + E0(0) )</span>

</pre>
</div>

<p>
The intuition was that the special values of <code>enc(0)</code>,
<code>dec(0,iv1=0,iv2=0)</code>, or <code>dec(0,iv1=X,iv2=0)</code> etc would somehow be
instrumental in unwrapping some of these constructs and finding
&ldquo;primitives&rdquo; (like <code>aes_ecb_encrypt(key,0)</code>) that can be looked up in
precomputed tables. (The keyspace for each of the three keys was only
24 bits so each on its own is easily brute forceable.)
</p>

<p>
The last part of the comment above is me discovering the starting
point for recovering <code>key0</code> and after that everything becomes easy.
</p>

<p>
The server has a very generous timeout which seems to indicate that
some of this brute forcing could take place to dynamically construct
messages for the server to encrypt/decrypt. Thus there&rsquo;s probably a
better way of doing this, but I didn&rsquo;t look very hard. The only
benefit to how I did is that no computation is needed when connected
to server, just fetch a few key values and disconnect. Code:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">from</span> flagmining.<span style="color: #c678dd;">all</span> <span style="color: #51afef;">import</span> *

<span style="color: #dcaeea;">z</span> = byte(<span style="color: #da8548; font-weight: bold;">0</span>)*<span style="color: #da8548; font-weight: bold;">16</span>
<span style="color: #dcaeea;">n_keys</span> = <span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">24</span>
<span style="color: #dcaeea;">ecb</span> = <span style="color: #51afef;">lambda</span> k: AES.new(k, mode=AES.MODE_ECB)

<span style="color: #51afef;">print</span>(<span style="color: #98be65;">"generating keys..."</span>)
<span style="color: #dcaeea;">keys</span> = [md5(<span style="color: #c678dd;">bytes</span>(b)).digest() <span style="color: #51afef;">for</span> b <span style="color: #51afef;">in</span> tqdm(product(<span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">256</span>), repeat=<span style="color: #da8548; font-weight: bold;">3</span>), total=n_keys)]

<span style="color: #51afef;">print</span>(<span style="color: #98be65;">'making lookup table...'</span>)
<span style="color: #dcaeea;">enc_to_key</span> = {ecb(k).encrypt(z): k
              <span style="color: #51afef;">for</span> k <span style="color: #51afef;">in</span> tqdm(keys, total=n_keys)}



<span style="color: #dcaeea;">r</span> = remote(<span style="color: #98be65;">'crypto.ctf.zer0pts.com'</span>, <span style="color: #da8548; font-weight: bold;">10929</span>)
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">[..] wrapping server communication in enc(), dec(), get_flag()</span>


<span style="color: #dcaeea;">Ez</span>, <span style="color: #dcaeea;">R0</span>, <span style="color: #dcaeea;">R1</span> = enc(z)
<span style="color: #dcaeea;">Pz</span> = dec(Ez, z, R1) <span style="color: #5B6268;"># </span><span style="color: #5B6268;">= D0(R0 ^ E0(0))</span>
<span style="color: #dcaeea;">Dz</span> = dec(z+z, z, z) <span style="color: #5B6268;"># </span><span style="color: #5B6268;">= D0(D1(E2(0))) || D0(D1(E2(0)) ^ E2(0))</span>
<span style="color: #dcaeea;">flag3</span>, <span style="color: #dcaeea;">flag_iv0</span>, <span style="color: #dcaeea;">flag_iv1</span> = get_flag()

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Done with server.</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Find the key0 which makes D(R0 ^ E(0)) == Pz.</span>
<span style="color: #dcaeea;">k0</span> = <span style="color: #a9a1e1;">None</span>
<span style="color: #51afef;">for</span> x,k <span style="color: #51afef;">in</span> tqdm(enc_to_key.items(), total=n_keys):
  <span style="color: #51afef;">if</span> ecb(k).decrypt(xor_bytes(x, R0)) == Pz:
    <span style="color: #dcaeea;">k0</span> = k
    <span style="color: #51afef;">break</span>
<span style="color: #51afef;">assert</span> k0
<span style="color: #51afef;">print</span>(<span style="color: #98be65;">"found key0:"</span>, k0)

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Now unwrap Dz and just look up key2 from table.</span>
<span style="color: #dcaeea;">ciph0</span> = ecb(k0)
<span style="color: #dcaeea;">k2</span> = enc_to_key.get(xor_bytes(
  ciph0.encrypt(Dz[:<span style="color: #da8548; font-weight: bold;">16</span>]),
  ciph0.encrypt(Dz[<span style="color: #da8548; font-weight: bold;">16</span>:])), <span style="color: #a9a1e1;">None</span>)
<span style="color: #51afef;">assert</span> k2
<span style="color: #51afef;">print</span>(<span style="color: #98be65;">"found key2:"</span>, k2)

<span style="color: #dcaeea;">flag2</span> = AES.new(k2, mode=AES.MODE_CFB, iv=flag_iv1, segment_size=<span style="color: #da8548; font-weight: bold;">8</span>*<span style="color: #da8548; font-weight: bold;">16</span>).decrypt(flag3)

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Now find the middle key that gives the flag.</span>
<span style="color: #51afef;">print</span>(<span style="color: #98be65;">"finding k1..."</span>)
<span style="color: #51afef;">for</span> k1 <span style="color: #51afef;">in</span> tqdm(keys):
  <span style="color: #dcaeea;">flag0</span> = ciph0.decrypt( AES.new(k1, mode=AES.MODE_CBC, iv=flag_iv0).decrypt(flag2) )
  <span style="color: #51afef;">if</span> b<span style="color: #98be65;">'zer0'</span> <span style="color: #51afef;">in</span> flag0:
    <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"found k1:"</span>, k1)
    <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"found flag:"</span>, flag0)
    <span style="color: #51afef;">break</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-orga412e49" class="outline-3">
<h3 id="orga412e49">Kantan Calc</h3>
<div class="outline-text-3" id="text-orga412e49">
<p>
No, I forgot one, but it kinda doesn&rsquo;t count. Sunday I went for my
usual walk across the ice, and feeling refreshed I opened this one.
<code>poiko</code> had mentioned it briefly before, but I misunderstood the task
slightly and hadn&rsquo;t seen the source, so my suggestions at the time
were dead ends.
</p>

<p>
But now (with source) I got the right idea (or at least <i>a</i> right
idea):
</p>

<div class="org-src-container">
<pre class="src src-javascript">
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">012345678901234567890123456789/* flag */})()</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">});(function x() {return x</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">});(()=&gt;()=&gt;{</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">});u=(s)=&gt;()=&gt;[...''+s];u(()=&gt;{</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">});((s)=&gt;()=&gt;[...''+s])(()=&gt;{</span>

</pre>
</div>

<p>
Again I&rsquo;m sort of &ldquo;thinking&rdquo; in comments.
</p>

<p>
The first two return the string of the function but are blocked by the
app because the substring <code>zer0pts</code> is blacklisted. That was a bit
annoying to circumvent because I know next to nothing about JS. With
the last two the idea is to convert the string to an array so it gets
<code>t,r,a,n,s,f,o,r,m,e,d</code> and bypasses the blacklist. The last one is
below length limit and works.
</p>

<p>
Should have also checked the main site tho, because turns out the CTF
was already over when I did this one.
</p>
</div>
</div>
</div>

<div id="outline-container-org3f89bf9" class="outline-2">
<h2 id="org3f89bf9">Misc/Zh3r0 2021</h2>
<div class="outline-text-2" id="text-org3f89bf9">
</div>
<div id="outline-container-misc2021" class="outline-3">
<h3 id="misc2021">General Comments</h3>
<div class="outline-text-3" id="text-misc2021">
<p>
<code>poiko</code> has been sneaking a few problems to me on the side from
various CTFs. I didn&rsquo;t take many notes, don&rsquo;t remember most of them,
but here are some.
</p>
</div>
</div>

<div id="outline-container-orga613d87" class="outline-3">
<h3 id="orga613d87">Boring MT blah (Zh3r0)</h3>
<div class="outline-text-3" id="text-orga613d87">
<p>
Basic problem was as follows:
</p>

<div class="org-src-container">
<pre class="src src-python">  <span style="color: #51afef;">import</span> numpy.random <span style="color: #51afef;">as</span> random

  <span style="color: #51afef;">def</span> <span style="color: #c678dd;">rand_32</span>():
      <span style="color: #51afef;">return</span> <span style="color: #c678dd;">int</span>.from_bytes(os.urandom(<span style="color: #da8548; font-weight: bold;">4</span>),<span style="color: #98be65;">'big'</span>)

  <span style="color: #51afef;">for</span> _ <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">2</span>):
      <span style="color: #5B6268;"># </span><span style="color: #5B6268;">hate to do it twice, but i dont want people bruteforcing it</span>
      random.seed(rand_32())
      <span style="color: #dcaeea;">iv</span>,<span style="color: #dcaeea;">key</span> = random.<span style="color: #c678dd;">bytes</span>(<span style="color: #da8548; font-weight: bold;">16</span>), random.<span style="color: #c678dd;">bytes</span>(<span style="color: #da8548; font-weight: bold;">16</span>)
      <span style="color: #dcaeea;">cipher</span> = AES.new(key,iv=iv,mode=AES.MODE_CBC)
      <span style="color: #dcaeea;">flag</span> = iv+cipher.encrypt(flag)
</pre>
</div>

<p>
So a 32-bit seed is used with <code>numpy.random.seed()</code>, but we have to
get through two of them.
</p>

<p>
When I first looked at the code I was somewhat excited because newer
<code>numpy</code> uses PCG64, which I think is a really cool RNG, and would be
quite interesting to reverse, however, the <code>seed()</code> stuff just uses
the legacy implementation, which is a Mersenne Twister, basically
equivalent to Python&rsquo;s (though some differences in initialization).
</p>

<p>
Mersenne Twister is one of the more boring RNGs (in my opinion), but
I&rsquo;m also biased by the fact that it has a lot of finickiness with
implementation and it&rsquo;s so easy to get stuck on off-by-one bugs or
stuff like that. Basically, its implementation is more of a hassle
than the RNG is worth. It also has, in my opinion, a greatly
disproportionate state size for its quality.
</p>

<p>
Anyway, there&rsquo;s two approaches to this problem. One, the &ldquo;trve&rdquo; way,
is to actually directly reverse the 32-bit seed from the 16 bytes of
output you get for free. Now, I know that this can be done but it is
also not trivial, because the MT implementations use a
super-convoluted initailization, and you have to copy all this code
and make sure you get all the indexing right and it&rsquo;s just a royal
pain in the ass with all the potential bugs.
</p>

<p>
The second approach, the &ldquo;I don&rsquo;t want to deal with this shit&rdquo;
approach, is to note that you can get as many of these outputs as you
want. So you can build a database of <code>output-bytes -&gt; seed</code> or
something like that, and then just get enough outputs from the server
until it&rsquo;s very likely you get two matches. I think the probability
calculation might go like \(1-(1-\frac{d}{2^{32}})^h\) (?) where \(d\) is
the number of entries you put in the database and \(h\) is the number of
times you hit up the server. So calculating ~200 million seeds (not
too bad, time-wise) while <code>nc</code>-ing the server 400 times (also not too
bad, because there&rsquo;s no PoW), gives you a fair chance of being able to
decrypt both ciphers.
</p>

<p>
I went for the second approach, which was simple and braindead.
</p>
</div>
</div>

<div id="outline-container-org46eff17" class="outline-3">
<h3 id="org46eff17">A<sub>52</sub> group (unknown CTF)</h3>
<div class="outline-text-3" id="text-org46eff17">
<p>
I remember one problem he described where you are to find two elements
in the alternating group \(a,b \in A_{52}\) such that given any deck
shuffle (of 52 cards) you can give a sequence of \(a b^2 a b^{13} a^{5} \cdots\) which gives that shuffle. I don&rsquo;t know the exact problem
statement, or what category it was in (guessing <code>rev</code> or <code>misc</code>), but
it was an interesting little problem for being something I haven&rsquo;t
seen before.
</p>

<p>
Basically what I came up with is to have one element (the big loop)
cycle the first 51 cards like <code>(0 1 2 … 49 50)</code> and then another (the
little loop) which cycles the last three cards like <code>(49 50 51)</code>. And
then you can think of it as a really bad sorting algorithm, where you
incrementally start to sort the cards in the big loop (<code>0..50</code>) by
using the 51st place as a register or temporary variable. You shift
the card you want to move into position 51, then align the rest of the
cards properly, then shift it out again, rinse repeat until all the
cards are sorted (or in whatever order you want). There&rsquo;s a special
case when the card you want to move is attached to the front or back
of the sequence of already-sorted cards (and you want to move it to
the other side) in the &ldquo;big loop,&rdquo; but it&rsquo;s easy to take care of.
</p>
</div>
</div>

<div id="outline-container-org1bd91cd" class="outline-3">
<h3 id="org1bd91cd">Unicode troll (unknown CTF)</h3>
<div class="outline-text-3" id="text-org1bd91cd">
<p>
There was another problem that appeared to be a RNG reverse, but was
just a troll task.
</p>

<p>
You give a seed as hex, it has various conditions applied to it, then
the digits in your seed is scrambled, and you are given two bytes of
output in an xorshift64 stream and asked to predict the value. The
relevant part was:
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #dcaeea;">seed</span> = <span style="color: #c678dd;">input</span>(<span style="color: #98be65;">"give me the seed: "</span>)
    <span style="color: #dcaeea;">seed</span> = seed.strip()

    <span style="color: #51afef;">if</span>(<span style="color: #c678dd;">len</span>(seed)) != SEEDS:
        <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"seed should be "</span>+<span style="color: #c678dd;">str</span>(SEEDS)+<span style="color: #98be65;">" bytes long!"</span>)
        <span style="color: #a9a1e1;">exit</span>()

    <span style="color: #dcaeea;">seed</span> = <span style="color: #c678dd;">list</span>(seed)
    random.shuffle(seed)

    <span style="color: #dcaeea;">counts</span> = collections.Counter(seed)
    <span style="color: #51afef;">if</span> counts.most_common()[<span style="color: #da8548; font-weight: bold;">0</span>][<span style="color: #da8548; font-weight: bold;">1</span>] &gt; <span style="color: #da8548; font-weight: bold;">3</span>:
            <span style="color: #51afef;">print</span> (<span style="color: #98be65;">"You can't use the same number more than 3 times!"</span>)
            <span style="color: #a9a1e1;">exit</span>()

    <span style="color: #dcaeea;">int16</span> = <span style="color: #51afef;">lambda</span> x: <span style="color: #c678dd;">int</span>(x,<span style="color: #da8548; font-weight: bold;">16</span>)
    <span style="color: #dcaeea;">seed</span> = <span style="color: #c678dd;">list</span>(<span style="color: #c678dd;">map</span>(int16,seed))
</pre>
</div>

<p>
The suspicious part is where it does the <code>Counter()</code> stuff to check
for repeated digits. I got a hunch and yes, sure enough:
</p>

<div class="org-src-container">
<pre class="src src-python">  &gt;&gt;&gt; <span style="color: #c678dd;">int</span>(<span style="color: #98be65;">'1&#1632;&#1776;&#1984;&#2406;&#2534;&#2662;&#2790;&#2918;&#3046;&#3174;&#3302;&#3430;&#3558;&#3664;&#3792;&#3872;&#4160;&#4240;&#6112;&#6160;&#6470;&#6608;&#6784;&#6800;&#6992;&#7088;&#7232;&#7248;&#42528;&#43216;&#43264;&#43472;&#43504;&#43600;&#44016;&#65296;&#66720;&#68912;&#69734;&#69872;&#69942;&#70096;&#70384;&#70736;&#70864;&#71248;&#71360;&#71472;&#71904;&#72784;'</span>)
  <span style="color: #da8548; font-weight: bold;">100000000000000000000000000000000000000000000000000</span>
</pre>
</div>

<p>
So you can literally just feed it 0 as the seed and xorshift64 is trivially all zeros.
</p>

<p>
You can find these weird characters as follows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #83898d;">''</span>.join([<span style="color: #c678dd;">chr</span>(x) <span style="color: #51afef;">for</span> x <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">256</span>,0x110000) <span style="color: #51afef;">if</span> unicodedata.category(<span style="color: #c678dd;">chr</span>(x)) == <span style="color: #83898d;">'Nd'</span> <span style="color: #51afef;">and</span> unicodedata.digit(<span style="color: #c678dd;">chr</span>(x)) == <span style="color: #da8548; font-weight: bold;">0</span>])
</pre>
</div>

<p>
Apparently the task (in whatever CTF it was) was marked with <code>crypto</code> as well, which is why I call it a troll.
</p>
</div>
</div>

<div id="outline-container-orgae4e9c0" class="outline-3">
<h3 id="orgae4e9c0">homebrew hash function (Zh3r0)</h3>
<div class="outline-text-3" id="text-orgae4e9c0">
<p>
There was a hash function like
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">hash</span>(text:<span style="color: #c678dd;">bytes</span>):
    <span style="color: #dcaeea;">text</span> = pad(text)
    <span style="color: #dcaeea;">text</span> = [<span style="color: #c678dd;">int</span>.from_bytes(text[i:i+<span style="color: #da8548; font-weight: bold;">4</span>],<span style="color: #98be65;">'big'</span>) <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">0</span>,<span style="color: #c678dd;">len</span>(text),<span style="color: #da8548; font-weight: bold;">4</span>)]
    <span style="color: #dcaeea;">M</span> = 0xffff
    <span style="color: #dcaeea;">x</span>,<span style="color: #dcaeea;">y</span>,<span style="color: #dcaeea;">z</span>,<span style="color: #dcaeea;">u</span> = 0x0124fdce, 0x89ab57ea, 0xba89370a, 0xfedc45ef
    <span style="color: #dcaeea;">A</span>,<span style="color: #dcaeea;">B</span>,<span style="color: #dcaeea;">C</span>,<span style="color: #dcaeea;">D</span> = 0x401ab257, 0xb7cd34e1, 0x76b3a27c, 0xf13c3adf
    <span style="color: #dcaeea;">RV1</span>,<span style="color: #dcaeea;">RV2</span>,<span style="color: #dcaeea;">RV3</span>,<span style="color: #dcaeea;">RV4</span> = 0xe12f23cd, 0xc5ab6789, 0xf1234567, 0x9a8bc7ef
    <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">0</span>,<span style="color: #c678dd;">len</span>(text),<span style="color: #da8548; font-weight: bold;">4</span>):
        <span style="color: #dcaeea;">X</span>,<span style="color: #dcaeea;">Y</span>,<span style="color: #dcaeea;">Z</span>,<span style="color: #dcaeea;">U</span> = text[i]^x,text[i+<span style="color: #da8548; font-weight: bold;">1</span>]^y,text[i+<span style="color: #da8548; font-weight: bold;">2</span>]^z,text[i+<span style="color: #da8548; font-weight: bold;">3</span>]^u
        <span style="color: #dcaeea;">RV1</span> ^= (x := (X&amp;0xffff)*(M - (Y&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(Z,<span style="color: #da8548; font-weight: bold;">1</span>) ^ ROTR(U,<span style="color: #da8548; font-weight: bold;">1</span>) ^ A)
        <span style="color: #dcaeea;">RV2</span> ^= (y := (Y&amp;0xffff)*(M - (Z&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(U,<span style="color: #da8548; font-weight: bold;">2</span>) ^ ROTR(X,<span style="color: #da8548; font-weight: bold;">2</span>) ^ B)
        <span style="color: #dcaeea;">RV3</span> ^= (z := (Z&amp;0xffff)*(M - (U&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(X,<span style="color: #da8548; font-weight: bold;">3</span>) ^ ROTR(Y,<span style="color: #da8548; font-weight: bold;">3</span>) ^ C)
        <span style="color: #dcaeea;">RV4</span> ^= (u := (U&amp;0xffff)*(M - (X&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(Y,<span style="color: #da8548; font-weight: bold;">4</span>) ^ ROTR(Z,<span style="color: #da8548; font-weight: bold;">4</span>) ^ D)
    <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">4</span>):
        <span style="color: #dcaeea;">RV1</span> ^= (x := (X&amp;0xffff)*(M - (Y&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(Z,<span style="color: #da8548; font-weight: bold;">1</span>) ^ ROTR(U,<span style="color: #da8548; font-weight: bold;">1</span>) ^ A)
        <span style="color: #dcaeea;">RV2</span> ^= (y := (Y&amp;0xffff)*(M - (Z&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(U,<span style="color: #da8548; font-weight: bold;">2</span>) ^ ROTR(X,<span style="color: #da8548; font-weight: bold;">2</span>) ^ B)
        <span style="color: #dcaeea;">RV3</span> ^= (z := (Z&amp;0xffff)*(M - (U&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(X,<span style="color: #da8548; font-weight: bold;">3</span>) ^ ROTR(Y,<span style="color: #da8548; font-weight: bold;">3</span>) ^ C)
        <span style="color: #dcaeea;">RV4</span> ^= (u := (U&amp;0xffff)*(M - (X&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(Y,<span style="color: #da8548; font-weight: bold;">4</span>) ^ ROTR(Z,<span style="color: #da8548; font-weight: bold;">4</span>) ^ D)
    <span style="color: #51afef;">return</span> <span style="color: #c678dd;">int</span>.to_bytes( (RV1&lt;&lt;<span style="color: #da8548; font-weight: bold;">96</span>)|(RV2&lt;&lt;<span style="color: #da8548; font-weight: bold;">64</span>)|(RV3&lt;&lt;<span style="color: #da8548; font-weight: bold;">32</span>)|RV4 ,<span style="color: #da8548; font-weight: bold;">16</span>,<span style="color: #98be65;">'big'</span>)
</pre>
</div>

<p>
And the goal was to find a collision. Stripping away all the trivially
reversible fluff, what we want to attack is:
</p>

<div class="org-src-container">
<pre class="src src-python">  <span style="color: #dcaeea;">RV1</span> ^= (X&amp;0xffff)*(M - (Y&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(Z,<span style="color: #da8548; font-weight: bold;">1</span>) ^ ROTR(U,<span style="color: #da8548; font-weight: bold;">1</span>)
  <span style="color: #dcaeea;">RV2</span> ^= (Y&amp;0xffff)*(M - (Z&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(U,<span style="color: #da8548; font-weight: bold;">2</span>) ^ ROTR(X,<span style="color: #da8548; font-weight: bold;">2</span>)
  <span style="color: #dcaeea;">RV3</span> ^= (Z&amp;0xffff)*(M - (U&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(X,<span style="color: #da8548; font-weight: bold;">3</span>) ^ ROTR(Y,<span style="color: #da8548; font-weight: bold;">3</span>)
  <span style="color: #dcaeea;">RV4</span> ^= (U&amp;0xffff)*(M - (X&gt;&gt;<span style="color: #da8548; font-weight: bold;">16</span>)) ^ ROTL(Y,<span style="color: #da8548; font-weight: bold;">4</span>) ^ ROTR(Z,<span style="color: #da8548; font-weight: bold;">4</span>)
</pre>
</div>

<p>
Specifically, the only thing that is nonlinear here is the
multiplication. I think you could approach this in several ways, like
a sort of backward search on each block, or try to find out how two
blocks can cancel each other out, but as a preliminary I put it into
z3 first. I had a suspicion that you can solve the above for several
instances of <code>X, Y, Z, U</code> to get a collision in the very first 16
bytes, or at least I couldn&rsquo;t see why it shouldn&rsquo;t be possible. But
sure enough, z3 found such an instance pretty quickly (fixing one
variable to be anything to ground it) and it was just done. Whatever
else in the data doesn&rsquo;t matter.
</p>
</div>
</div>

<div id="outline-container-orgd8145e1" class="outline-3">
<h3 id="orgd8145e1">almost-combinadics (Zh3r0)</h3>
<div class="outline-text-3" id="text-orgd8145e1">
<p>
The problem was:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">nk2n</span>(nk):
    <span style="color: #dcaeea;">l</span> = <span style="color: #c678dd;">len</span>(nk)
    <span style="color: #51afef;">if</span> l == <span style="color: #da8548; font-weight: bold;">1</span>:
        <span style="color: #51afef;">return</span> nk[<span style="color: #da8548; font-weight: bold;">0</span>]
    <span style="color: #51afef;">elif</span> l == <span style="color: #da8548; font-weight: bold;">2</span>:
        <span style="color: #dcaeea;">i</span>,<span style="color: #dcaeea;">j</span> = nk
        <span style="color: #51afef;">return</span> ((i+j) * (i+j+<span style="color: #da8548; font-weight: bold;">1</span>)) // <span style="color: #da8548; font-weight: bold;">2</span> + j
    <span style="color: #51afef;">return</span> nk2n([nk2n(nk[:l-l//<span style="color: #da8548; font-weight: bold;">2</span>]), nk2n(nk[l-l//<span style="color: #da8548; font-weight: bold;">2</span>:])])

<span style="color: #51afef;">print</span>(nk2n(flag))
<span style="color: #5B6268;">#</span><span style="color: #5B6268;">2597749519984520018193538914972744028780767067373210633843441892910830749749277631182596420937027368405416666234869030284255514216592219508067528406889067888675964979055810441575553504341722797908073355991646423732420612775191216409926513346494355434293682149298585</span>
</pre>
</div>

<p>
Right off the bat there was a strong &ldquo;smell&rdquo; of some sort of &ldquo;exotic
base conversion&rdquo; here, and I mentioned combinatorial number system to
<code>poiko</code>. He pointed out that indeed, the case of <code>l==2</code> above is
<code>choose(i+j+1,2)+j</code>. That made it click for me even though the whole
combinatorial angle isn&rsquo;t really needed or relevant, the idea is just
that the <code>l==2</code> step is easily reversible:
</p>

<div class="org-src-container">
<pre class="src src-python">  <span style="color: #51afef;">def</span> <span style="color: #c678dd;">rev</span>(q):
    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">q == comb(i+j+1,2) + j</span>
    <span style="color: #dcaeea;">r</span> = iroot(<span style="color: #da8548; font-weight: bold;">2</span>*q,<span style="color: #da8548; font-weight: bold;">2</span>)[<span style="color: #da8548; font-weight: bold;">0</span>]
    <span style="color: #51afef;">if</span> comb(r+<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>) &lt; q: <span style="color: #dcaeea;">r</span> += <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">r == i+j+1</span>
    <span style="color: #dcaeea;">j</span> = q - comb(r,<span style="color: #da8548; font-weight: bold;">2</span>)
    <span style="color: #dcaeea;">i</span> = r - j - <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #51afef;">return</span> (i,j)
</pre>
</div>

<p>
So you can simply keep calling <code>rev(v)</code> on all the numbers <code>&gt;255</code>
until all you have is bytes, and the flag comes out.
</p>
</div>
</div>

<div id="outline-container-org22b8ceb" class="outline-3">
<h3 id="org22b8ceb">approximate mastermind (Zh3r0)</h3>
<div class="outline-text-3" id="text-org22b8ceb">
<p>
This was a PPC task of solving Mastermind when the server sometimes
(with a low probability) lies in its responses. Full disclosure is I
didn&rsquo;t solve this one until after the CTF, so unfortunately no points
for <code>mode13h</code> but it was interesting enough.
</p>

<p>
So my first idea was to do the classical solution, (because the number
of pegs and colors were low in the challenge games,) which is to
enumerate all possible solution and weed out ones that didn&rsquo;t match
the constraints, and, if this leads to 0 possible solutions because
the server lied at some point, to sort of backtrack and remove one of
the constraints until it is consistent again. This obviously won&rsquo;t
work if the server lies too much, but the hope was that I could just
retry the game until the server lied few enough times,
probabilistically.
</p>

<p>
I did this with <code>numpy</code> to make it somewhat efficient, something like
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">c_bulls</span>(a,b):
  <span style="color: #51afef;">return</span> (a == b).<span style="color: #c678dd;">sum</span>(<span style="color: #da8548; font-weight: bold;">1</span>, dtype=np.int8)

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">c_cows</span>(C,a,b):
  <span style="color: #dcaeea;">b</span> = <span style="color: #c678dd;">tuple</span>(b)
  <span style="color: #dcaeea;">c</span> = np.zeros((a.shape[<span style="color: #da8548; font-weight: bold;">0</span>],), a.dtype)
  <span style="color: #51afef;">for</span> k <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(C):
    <span style="color: #dcaeea;">bc</span> = b.count(k)
    <span style="color: #51afef;">if</span> bc == <span style="color: #da8548; font-weight: bold;">0</span>:
      <span style="color: #51afef;">continue</span>
    <span style="color: #dcaeea;">x</span> = (a==k).<span style="color: #c678dd;">sum</span>(<span style="color: #da8548; font-weight: bold;">1</span>, dtype=np.int8)
    <span style="color: #dcaeea;">c</span> += np.<span style="color: #c678dd;">min</span>(x, bc)
  <span style="color: #51afef;">return</span> c
</pre>
</div>

<p>
(Here <code>a</code> is a <code>k×P</code> matrix of &ldquo;potential solutions.&rdquo; Note also
<code>c_cows()</code> include the bull count, which I find more intuitive,
whereas the server essentially uses <code>cows = c_cows() - c_bulls()</code>.)
</p>

<p>
To select a next guess I sampled some of the potential solutions and
found ones that would lead to the most other candidates being
eliminated no matter the response (min-max). Anyway, it wasn&rsquo;t the
fastest, and I ran into some weird (hidden) timeout issues and it kept
failing. I don&rsquo;t know what the timeout on the server actually was,
because it wasn&rsquo;t explicitly stated, which was annoying.
</p>

<p>
I then changed it to use a different approach, where I would generate
a small set of &ldquo;best candidates&rdquo; solutions (initially random) and just
keep iteritatively randomizing them until reaching some local maximum
where they would all give approximately the same answers as the
answers I had gotten from the server, adding more random candidates
that again get mutated down to &ldquo;good candidates&rdquo; when previous ones
end up identical. For each guess I just used the best candidate I had
so far.
</p>

<div class="org-src-container">
<pre class="src src-python">  <span style="color: #51afef;">def</span> <span style="color: #c678dd;">local_mutate</span>(<span style="color: #51afef;">self</span>, ch):
    <span style="color: #dcaeea;">tmp</span> = <span style="color: #c678dd;">list</span>(ch)
    <span style="color: #dcaeea;">f</span> = <span style="color: #51afef;">self</span>.score(ch)
    <span style="color: #dcaeea;">order</span> = <span style="color: #c678dd;">list</span>(<span style="color: #c678dd;">range</span>(<span style="color: #51afef;">self</span>.P))
    random.shuffle(order)
    <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> order:
      p, <span style="color: #dcaeea;">tmp</span>[i] = tmp[i], random.randrange(<span style="color: #51afef;">self</span>.N)
      <span style="color: #dcaeea;">nf</span> = <span style="color: #51afef;">self</span>.score(tmp)
      <span style="color: #51afef;">if</span> nf &lt; f:
        <span style="color: #dcaeea;">f</span> = nf
      <span style="color: #51afef;">else</span>:
        <span style="color: #dcaeea;">tmp</span>[i] = p
    <span style="color: #51afef;">return</span> f, <span style="color: #c678dd;">tuple</span>(tmp)

  <span style="color: #51afef;">def</span> <span style="color: #c678dd;">score</span>(<span style="color: #51afef;">self</span>, cand):
    <span style="color: #83898d;">"Score a guess based on previous guesses and responses"</span>
    <span style="color: #dcaeea;">f</span> = <span style="color: #da8548; font-weight: bold;">0.0</span>
    <span style="color: #dcaeea;">cntc</span> = Counter(cand)
    <span style="color: #51afef;">for</span> g, r, w <span style="color: #51afef;">in</span> <span style="color: #51afef;">self</span>.history:
      <span style="color: #dcaeea;">r_</span> = <span style="color: #c678dd;">sum</span>(x==y <span style="color: #51afef;">for</span> x,y <span style="color: #51afef;">in</span> <span style="color: #c678dd;">zip</span>(g,cand))
      <span style="color: #dcaeea;">w_</span> = <span style="color: #c678dd;">sum</span>((Counter(g) &amp; cntc).values())
      <span style="color: #dcaeea;">f</span> += <span style="color: #51afef;">self</span>.bull_weight * <span style="color: #c678dd;">abs</span>(r_-r)
      <span style="color: #dcaeea;">f</span> += <span style="color: #c678dd;">abs</span>(w_-w)
    <span style="color: #51afef;">return</span> f
</pre>
</div>

<p>
This is more of a genetic algorithm approach, kind of similar to
something I&rsquo;ve done when finding a factorization where the primes had
very specific bit patterns applied to them. It turned out this
approach worked surprisingly well actually, and immediately gave the
flag:
</p>

<div class="org-src-container">
<pre class="src src-python">  b<span style="color: #98be65;">'level passed, good job\n'</span>
  b<span style="color: #98be65;">'you earned it : zh3r0{wh3n_3asy_g4m3s_b3come_unnecessarily_challenging}\n'</span>
</pre>
</div>

<p>
It was also much faster than the full &ldquo;brute force&rdquo; numpy solution,
even though here I did everything in slow Python code.
</p>
</div>
</div>
</div>


<div id="outline-container-org38f8333" class="outline-2">
<h2 id="org38f8333">perfectblue CTF 2021</h2>
<div class="outline-text-2" id="text-org38f8333">
</div>
<div id="outline-container-pbctf2021" class="outline-3">
<h3 id="pbctf2021">General Comments</h3>
<div class="outline-text-3" id="text-pbctf2021">
<p>
I didn&rsquo;t play it, but I solved all the crypto tasks. Two of them I solved
for <code>poiko</code> on Sunday while the competition was running.
</p>

<p>
They were pretty cool overall. Didn&rsquo;t look at any of the misc tasks, the zip
<code>poiko</code> gave me just had these problems.
</p>
</div>
</div>

<div id="outline-container-org23dea4e" class="outline-3">
<h3 id="org23dea4e">Alkaloid Stream</h3>
<div class="outline-text-3" id="text-org23dea4e">
<p>
<code>poiko</code> had already solved this one during the actual CTF, I just re-solved it
out of own curiosity. Even &ldquo;easy&rdquo; problems can be quite enjoyable when made by
good problem authors (which I know <code>rbtree</code> to be).
</p>

<p>
Anyway, the task: I don&rsquo;t recall the name used for this kind of system, but it&rsquo;s
a discrimination problem, where we&rsquo;re trying to distinguish values that are are
part of some set from fake ones. Here, the true values are linearly independent
vectors in \(\mathbb{F}_2\) and the fakes are linear combinations from this basis. In a random order you get two numbers \((X,Y)\) where one is true and one is false.
</p>

<p>
In this specific problem none of this is important though, because it is
trivially bugged. The fake values are generated from contiguous sums but the
loops are bugged so the last fake value generated is always 0, allowing us to
distinguish some true value \(t_i\). The penultimate fake value will be \(t_i\)
itself, allowing us to find another \(t_j\) and so forth.
</p>

<p>
The solve was about half an hour(?) from reading to flag.
</p>
</div>
</div>

<div id="outline-container-org1f962ff" class="outline-3">
<h3 id="org1f962ff">Steroid Stream</h3>
<div class="outline-text-3" id="text-org1f962ff">
<p>
As above, but now the fake value \(i\) is generated from some a random subset (of
size \(\lfloor \frac{n}{3} \rfloor\)) from \(t_{i}, t_{i+1}, t_{i+2}, \cdots\).
However it is still bugged, because the last \(\lfloor\frac{n}{3} \rfloor\) fake
values are not generated at all, so they just default to 0. So immediately we
have the tail end of the original true values. From there it&rsquo;s just a matter of
iterating over the other values \((x,y)\) and checking if the rank of the matrix
increases when we add one of these numbers but not the other (pretending the
numbers represent a matrix over \(\mathbb{F}_2\)).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5B6268;"># </span><span style="color: #5B6268;">Code extract for solve. Much, much slower than it needs to be</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">(at least O(n^4) in Python-ops, but I believe O(n^3) should be possible?)</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">but fast enough for the task (couple of minutes).</span>

<span style="color: #dcaeea;">mat</span> = []
<span style="color: #dcaeea;">KEY</span> = [<span style="color: #da8548; font-weight: bold;">0</span>] * <span style="color: #c678dd;">len</span>(pks)

<span style="color: #51afef;">for</span> i,xy <span style="color: #51afef;">in</span> <span style="color: #c678dd;">enumerate</span>(pks):
  <span style="color: #dcaeea;">x</span>,<span style="color: #dcaeea;">y</span> = <span style="color: #c678dd;">sorted</span>(xy)
  <span style="color: #51afef;">if</span> x != <span style="color: #da8548; font-weight: bold;">0</span>:
    <span style="color: #51afef;">continue</span>
  mat.append(y)
  <span style="color: #dcaeea;">KEY</span>[i] = xy[<span style="color: #da8548; font-weight: bold;">0</span>] == <span style="color: #da8548; font-weight: bold;">0</span>

<span style="color: #dcaeea;">r</span> = bit_rank(mat)
<span style="color: #51afef;">while</span> r &lt; <span style="color: #c678dd;">len</span>(pks):
  <span style="color: #51afef;">for</span> i,xy <span style="color: #51afef;">in</span> <span style="color: #c678dd;">enumerate</span>(pks):
    <span style="color: #51afef;">if</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #51afef;">in</span> xy:
      <span style="color: #51afef;">continue</span>
    <span style="color: #dcaeea;">n0</span> = bit_rank(mat + [xy[<span style="color: #da8548; font-weight: bold;">0</span>]])
    <span style="color: #dcaeea;">n1</span> = bit_rank(mat + [xy[<span style="color: #da8548; font-weight: bold;">1</span>]])
    <span style="color: #51afef;">if</span> n0 == n1:
      <span style="color: #51afef;">continue</span>
    <span style="color: #dcaeea;">which</span> = n0 &lt; n1
    mat.append(xy[which])
    <span style="color: #dcaeea;">xy</span>[<span style="color: #da8548; font-weight: bold;">1</span>-which] = <span style="color: #da8548; font-weight: bold;">0</span>
    <span style="color: #dcaeea;">KEY</span>[i] = which
    <span style="color: #dcaeea;">r</span> += <span style="color: #da8548; font-weight: bold;">1</span>
</pre>
</div>

<p>
<code>bit_rank()</code> above is just naive elimination from my <code>flagmining</code> library:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dcaeea;">lowbit</span> = <span style="color: #51afef;">lambda</span> x: x &amp; -x

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">...</span>

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">bit_rank</span>(ns):
  <span style="color: #83898d;">"""Pretend the numbers represent a matrix over GF2 and calculate its rank.</span>

<span style="color: #83898d;">  """</span>
  <span style="color: #dcaeea;">mat</span> = <span style="color: #c678dd;">list</span>(ns)
  <span style="color: #dcaeea;">r</span> = <span style="color: #da8548; font-weight: bold;">0</span>
  <span style="color: #51afef;">while</span> mat:
    <span style="color: #51afef;">if</span> (pivot := mat.pop()) == <span style="color: #da8548; font-weight: bold;">0</span>:
      <span style="color: #51afef;">continue</span>
    <span style="color: #dcaeea;">r</span> += <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #dcaeea;">lb</span> = lowbit(pivot)
    <span style="color: #51afef;">for</span> i, row <span style="color: #51afef;">in</span> <span style="color: #c678dd;">enumerate</span>(mat):
      <span style="color: #51afef;">if</span> row &amp; lb:
        <span style="color: #dcaeea;">mat</span>[i] ^= pivot
  <span style="color: #51afef;">return</span> r

</pre>
</div>

<p>
Task was much simpler than I expected, and took just under an hour from reading
code to flag, according to my timestamps.
</p>
</div>
</div>

<div id="outline-container-org63210ee" class="outline-3">
<h3 id="org63210ee">GoodHash</h3>
<div class="outline-text-3" id="text-org63210ee">
<p>
A server accepts input strings that must strictly conform to being printable
ASCII, valid JSON, and for the JSON to contain the a property like <code>.admin==True</code>. This
string is hashed by using the output from <code>AES_GCM(key=&lt;fixed&gt;, data=bytes(32),
nonce=&lt;input&gt;, auth_data=None)</code> (both tag and ciphertext), and the hash is
compared against a known target value. The goal is to generate a collision while adhering to the constrained input format.
</p>

<p>
The path to the solution was easy enough to &ldquo;see&rdquo; after refreshing my memory on
GCM, but I put off actually implementing it for a long time (until I felt guilty
enough). I dislike GCM because there&rsquo;s always some non-trivial amount of fiddly
frustration and off-by-1 bugs and the like, due to the unintuitive LSB/MSB
schizophrenia it suffers from in actual implementation. So this one took several
(too many) hours just for that reason alone.
</p>

<p>
Basically when the nonce is not 96 bits exactly, and it&rsquo;s the only variable
factor, the &ldquo;point of collision&rdquo; reduces to this part of the GCM:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dcaeea;">h</span> = AES_ECB(key, <span style="color: #c678dd;">bytes</span>(<span style="color: #da8548; font-weight: bold;">16</span>))
<span style="color: #dcaeea;">cnt0</span> = GHASH(h, null_pad(IV) + (<span style="color: #da8548; font-weight: bold;">8</span>*<span style="color: #c678dd;">len</span>(IV)).to_bytes(<span style="color: #da8548; font-weight: bold;">16</span>, <span style="color: #98be65;">'big'</span>))
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">cnt0 is then used for the CTR keystream, to mask the auth data, and so forth.</span>
</pre>
</div>

<p>
And <code>GHASH(h, B)</code> works by evaluating the polynomial \(h^n B_1 + h^{n-1} B_2 +
\cdots + h B_n\) where \(B_i\) is 16-byte block \(i\) of the byte stream B, and all
byte-blocks are interpreted as values in \(\mathbb{F}_{2^{128}}\) under whatever
random bit order who the hell knows.
</p>

<p>
I took the most naive way forward (there might be better ways): a nonce like
<code>{"admin":1,"x":"////BLOCK[A]////....BLOCK[B]...."}</code> gives two completely free
blocks I can customize. If \(a,b,c,d,e\) are the blocks generated in the input to
<code>GHASH()</code> from this nonce (including the length block), then the task is to find
\(b,c\) of a suitable form such that \(b h + c = t = (a h^5 + d h^2 + e h) h^{-3}\)
in GCM&rsquo;s finite field.
</p>

<p>
To find these suitable \(b,c\) I again took the dumb approach, since I figured the
complexity was small enough and I just wanted it over with: generate random \(b\)
looking for values where either \(b h\) or \(b h + t\) has no bits in common with
\(128 \lfloor\frac{2^{128}}{255} \rfloor\) (i.e. no high bits set in any byte).
This finds candidates where the output is valid ASCII with 16-bit brute force.
Then do a small local search combining these sets to produce a valid form \(b\)
and \(c = b h + t\) where that ASCII also conforms to the allowable alphabet. Note
that the this first null-set is quote-unquote constant-time because it can be
generated as a table offline.
</p>
</div>
</div>

<div id="outline-container-org100ea52" class="outline-3">
<h3 id="org100ea52">Seed Me</h3>
<div class="outline-text-3" id="text-org100ea52">
<p>
A server running Java asks for a seed and requires that the <code>(2048*k)</code>-th
<code>float</code> output value for \(k \in [1,16]\) is larger than <code>~0.980155</code>. It smelled
like a lattice problem.
</p>

<p>
Upon inspection (<code>poiko</code> looked it up for me while I finished up <code>GoodHash</code>)
Java uses a simple 48-bit LCG and floats are made from the high 24 bits of the
state. LCGs were my first love in computer science topics and so has a special
place in my heart.
</p>

<p>
I set up:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5B6268;"># </span><span style="color: #5B6268;">[ -T0 -T1 -T2 ... -T15 B 0 ]</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">[  a0  a1  a2 ...  a15 0 1 ]</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">[  M   0   0  ....  0  0 0 ]</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">[  0   M   0  ....  0  0 0 ]</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">[  0   0   M  ....  0  0 0 ]</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">[         . . .            ]</span>
</pre>
</div>

<p>
&#x2026; where \(B \gg 2^{48}\), \(M = 2^{48}\) and the first 16 columns are also scaled
by some similarly large constant.
</p>

<p>
The target values \(T\) are constructed by seeking a sum close to the mid point
between lowest and highest acceptable value in the LCG range, i.e. <code>(2**48 +
int(2**48*7.331*0.1337))//2</code> offset by the added constant at that point in the
LCG stream.
</p>

<p>
This finds several good candidates, seeds that pass 14 or 15 of the given checks
but it doesn&rsquo;t find one that passes all 16. At this point I quietly complimented
the problem author for constructing a task that wasn&rsquo;t defeated by the most
naive cookie-cutter LLL approach. But noted also that the entropy of the
constraints is extremely low, far exceeding the seed space, so:
</p>

<ol class="org-ol">
<li>we&rsquo;re likely looking for a very specific seed that the problem author has
discovered or found somewhere,</li>
<li>indicating also that there&rsquo;s alternative solutions involving pure integer
programming, or by analyzing how Java&rsquo;s specific multiplier behaves in
2048-dimensional space,</li>
<li>in particular, it&rsquo;s likely that the hyperplanes of the LCG are
near-orthogonal to a specific axis in this space, and so lots of fun could be
had there.</li>
</ol>

<p>
But still, it&rsquo;s usually not that hard to &ldquo;convince&rdquo; LLL to find the answer you
want if you know it&rsquo;s there. I saw two obvious ways forward: adjust the target
to be slightly off-center, and/or use a non-uniform scale for the columns
applying uneven weight. I applied these techniques more or less randomly and
will admit to not really knowing much theory here (the &ldquo;I have no idea what I&rsquo;m
doing&rdquo; dog meme picture comes to mind), I just followed some basic instincts.
But randomizing the weights instantly nudged LLL in the right direction and
found a (the only?) seed that works.
</p>

<p>
Problem description to flag took around 1.5 hours so a pretty fast problem.
</p>
</div>
</div>

<div id="outline-container-orgecaebf2" class="outline-3">
<h3 id="orgecaebf2">Yet Another PRNG</h3>
<div class="outline-text-3" id="text-orgecaebf2">
<p>
This one was the most fun and enjoyable problem (in my view). It seemed simple
enough, it smelled of nuts (as in brain teasers), and I love Euler
hacking<sup><a id="fnr.23" class="footref" href="#fn.23" role="doc-backlink">23</a></sup>. It was decently challenging and rewarding. I am far from certain
I found the intended or most optimal solution.
</p>

<p>
The problem rephrased in conciser numpy code (numpy built into core CPython
when?) is as follows:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #5B6268;"># </span><span style="color: #5B6268;">These are justified as nothing-up-my-sleeve numbers.</span>
<span style="color: #dcaeea;">A</span> = np.array([[<span style="color: #da8548; font-weight: bold;">4256</span>, <span style="color: #da8548; font-weight: bold;">307568</span>, <span style="color: #da8548; font-weight: bold;">162667</span>],
              [<span style="color: #da8548; font-weight: bold;">593111</span>, <span style="color: #da8548; font-weight: bold;">526598</span>, <span style="color: #da8548; font-weight: bold;">630723</span>],
              [<span style="color: #da8548; font-weight: bold;">383732</span>, <span style="color: #da8548; font-weight: bold;">73391</span>, <span style="color: #da8548; font-weight: bold;">955684</span>]], <span style="color: #c678dd;">object</span>)

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">OBS 1: these are NOT justified...</span>
<span style="color: #dcaeea;">moduli</span> = np.array([<span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">32</span> - <span style="color: #da8548; font-weight: bold;">107</span>, <span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">32</span> - <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">32</span> - <span style="color: #da8548; font-weight: bold;">209</span>], dtype=<span style="color: #c678dd;">object</span>)
<span style="color: #dcaeea;">M</span> = <span style="color: #da8548; font-weight: bold;">2</span>**<span style="color: #da8548; font-weight: bold;">64</span> - <span style="color: #da8548; font-weight: bold;">59</span>

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">gen</span>(s):
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">We maintain three separate streams (as rows in `s`) and for each iteration</span>
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">the next stream value is some linear combination of the three previous</span>
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">values with coefficients from rows in A.</span>
  <span style="color: #5B6268;">#</span>
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">The streams are reduced with different moduli, and finally summed under a</span>
  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">fourth modulus.</span>
  <span style="color: #51afef;">while</span> <span style="color: #a9a1e1;">True</span>:
    <span style="color: #dcaeea;">out</span> = s[:,<span style="color: #da8548; font-weight: bold;">0</span>] * [<span style="color: #da8548; font-weight: bold;">2</span>*moduli[<span style="color: #da8548; font-weight: bold;">0</span>], -moduli[<span style="color: #da8548; font-weight: bold;">2</span>], -moduli[<span style="color: #da8548; font-weight: bold;">1</span>]]  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">OBS 2: the order.</span>
    <span style="color: #51afef;">yield</span> <span style="color: #c678dd;">sum</span>(out) % M  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">summed under a fourth modulus</span>
    <span style="color: #dcaeea;">n</span> = (s*A).<span style="color: #c678dd;">sum</span>(<span style="color: #da8548; font-weight: bold;">1</span>) % moduli  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">each stream gets its own modulus</span>
    <span style="color: #dcaeea;">s</span> = np.c_[s[:,<span style="color: #da8548; font-weight: bold;">1</span>:], n]  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">cycle state: shift out the most recent numbers, add new ones</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">9x 32-bit unknowns.</span>
<span style="color: #dcaeea;">U</span> = np.array([[random.getrandbits(<span style="color: #da8548; font-weight: bold;">32</span>) <span style="color: #51afef;">for</span> _ <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">3</span>)] <span style="color: #51afef;">for</span> _ <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">3</span>)], dtype=<span style="color: #c678dd;">object</span>)
<span style="color: #dcaeea;">g</span> = gen(U)
<span style="color: #51afef;">for</span> _ <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">12</span>):
  <span style="color: #51afef;">print</span>(<span style="color: #c678dd;">next</span>(g))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">output "hints"</span>

<span style="color: #5B6268;"># </span><span style="color: #5B6268;">use next 12 outputs to encode flag.</span>
</pre>
</div>

<p>
I spent several wasteful hours going down misguided rabbit holes chasing clever
Euler hacks, which was unfruitful, but I had a lot of fun doing it. I don&rsquo;t have
a proper time estimate because I started preliminary analysis before bed and
then continued in the morning, but I would say I used <i>at least</i> 5 hours on this
problem, which I don&rsquo;t regret.
</p>

<p>
The final modulus does not seem like the difficult part, as it will only be
relevant half the time anyway, thus I decided early on to ignore it, figuring
that <i>if all else fails</i> it&rsquo;s a 12-bit brute force. The problem lies in
reasoning about these three values that have already been reduced by different
moduli by the time they&rsquo;re added using further arithmetic&#x2026;
</p>

<p>
My initial idea was to think of the original values in the unknown state as
faux-\(\mathbb{Q}\) values in order to unify the moduli calculation to something
under \(\pmod{m_0 m_1 m_2}\) or similar, but I was probably just being delusional.
However during this I made two important observations: the moduli were indeed
very suspicious. For example \(2 m_0 = m_1 + m_2\), which I assume is relevant,
but I didn&rsquo;t find a <i>direct</i> way to exploit it. I got the feeling there&rsquo;s some
clever insight I missed here, like &ldquo;oh! but that means we can just think of the
streams as blah blah in linear algebra&rdquo; but my brain didn&rsquo;t deliver on the blah
blah part.
</p>

<p>
Anyway, the second observation is how the multipliers switches order when giving
the final sum, mimicking CRT. The output is (ignoring the \(M\) modulus) \(2 m_0 (x
\pmod{m_0}) - m_2 (y \pmod{m_1}) - m_1 (z \pmod{m_2})\) (to be fair: this is much
clearer in the actual task than I made it seem in the numpy golf above), which
is equivalent to \((2 m_0 x \pmod{m_{0}^2}) - (m_2 y + m_1 z \pmod{m_1 m_2})\), so
that at least reduces it to two moduli.
</p>

<p>
And, but, aha! Now the moduli are twice the bit length, meaning that they&rsquo;re
&ldquo;applied&rdquo; less. Expanding, we have something like \(2 m_0 (c_0 x_0 + c_1 x_1 +
c_2 x_2) \pmod{m_{0}^2}\) for the first independent stream, where all the inner
values are 32-bit, so the \(k\) in \((\cdots) - r = m_0^2 k\) will also be around
32-bit.
</p>

<p>
\(m_{0}^2\) and \(m_1 m_2\) are very close, their difference is only \(102^2\), so
then the idea is as follows: pretend the modulus is some \(m'\) between theese two
values and then we have ourselves a good old lattice problem. The inaccuracy
introduced in each constraint will be \(\approx 32 + \log_2{102^2} - 1\), but the
modulus is ~64 bits, so we&rsquo;re still getting a handful of good bits of state per
equation.
</p>

<p>
And a final note is that the first 3 outputs are just combinations of the
original random values, meaning they are known to be accurate up to 1 overflow,
so they give a a ton of extra information. Likewise the fourth output has higher
accuracy than the rest due to the values in <code>A</code> being only 20 bits.
</p>

<p>
Now, factoring in the modulus \(M\) I ignored earlier, I didn&rsquo;t find a very
elegant way to do this, but brute forced it for the first four values, and
simply ignored it for the remaining constraints since the error it introduces
there is less than the error introduced by the pseudo-modulus \(m'\).
</p>

<p>
In the end I had some big, ugly lattice that is too ugly to reproduce here, but
it succeeded in finding all the original 9 seed values given the correct factor
of \(M\) for the first four output values (so 16 lattices).
</p>

<div class="org-src-container">
<pre class="src src-python">b<span style="color: #83898d;">'pbctf{Wow_how_did_you_solve_this?_I_thought_this_is_super_secure._Thank_you_for_solving_this!!!}'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb67f4f9" class="outline-3">
<h3 id="orgb67f4f9">Yet Another RSA</h3>
<div class="outline-text-3" id="text-orgb67f4f9">
<p>
When I first glanced at this problem I thought it was some weird elliptic curve
thing and that the title was a troll. I immediately became very suspicious that
it would be a Google-the-paper for one of those weird cryptosystems that
academics and grad students pump out. &ldquo;Diffie-Hellman over non-uniform smooth
Titmann-Buttworth groups of semi-regular order&rdquo; and then the incestuous follow
ups with &ldquo;Analysis of &#x2026;&rdquo; and &ldquo;Attack against &#x2026;&rdquo;. (If I sound bitter it&rsquo;s only
because I&rsquo;m jealous.)
</p>

<p>
So, OK, the problem&#x2026;is to find the logarithm of a number under some scarily
complicated group operation. All arithmetic is performed modulo some RSA-number
\(n = p q\). My initial glance quickly proved wrong, it definitely wasn&rsquo;t an
elliptic curve. The group has apparent order \((p^2 + p + 1) (q^2 + q + 1)\) whose
representation is given as two numbers in \(\mathbb{Z}_n^{*} \cup {None}\) (or
something like that, anyway). The primes used have the special form \(a^2 + 3
b^2\), the private exponent is suspiciously low, and so on. Tons and tons of red
flags screaming &ldquo;Google me.&rdquo;
</p>

<p>
But first thing I did was to simplify. I looked at the case where the modulo was
a single prime and tried (in vain) to reason about what the hell the group
operation &ldquo;did&rdquo; to points geometrically or visually by looking at easy stuff
like \((1,2) * (2,1), (-1,2) * (1,2), (-2,1) * (1,-2), etc\) and expressing the
results in human-readable p-fractions (e.g. showing each coordinate as
\(\frac{n}{d} \pmod{p}\) when such \(n,d\) of small absolute value can be found
easily). It wasn&rsquo;t particularly enlightening.
</p>

<p>
I tried to Google-the-paper at this point but didn&rsquo;t find anything promising so
I just started a Wikipedia-hole instead. I came across the projective linear
group and duh, the rather obvious \(p^2 + p + 1 = \frac{p^3 - 1}{p-1}\) finally
hit me. Thus I figured it was modelling some operation over the projective plane
(thus all the &ldquo;fractions&rdquo;), and from the clue of \(p^3 - 1\) I carefully
re-examined the group operation while thinking about \(\mathbb{F}_{p^3}\) and yes
indeed, it was modelling multiplication over \(\mathbb{Z}_{pq}[X]/(X^3-2)\)!
(Where \(projective \approx monic\), to really abuse math terms.)
</p>

<p>
I also wrote a quick utility class for playing with this group properly. (Here
modified with stuff I discovered below.)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">mk_point</span>(N, r):
  <span style="color: #dcaeea;">display</span> = <span style="color: #51afef;">lambda</span> x: <span style="color: #c678dd;">min</span>(x-N, x, key=<span style="color: #c678dd;">abs</span>)
  <span style="color: #ECBE7B;">@dataclass</span>(eq=<span style="color: #a9a1e1;">False</span>, unsafe_hash=<span style="color: #a9a1e1;">True</span>)
  <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">_pt</span>:
    x: <span style="color: #c678dd;">int</span>
    y: <span style="color: #c678dd;">int</span>
    z: <span style="color: #c678dd;">int</span> = <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__iter__</span>(<span style="color: #51afef;">self</span>):
      <span style="color: #51afef;">return</span> <span style="color: #c678dd;">iter</span>((<span style="color: #51afef;">self</span>.x, <span style="color: #51afef;">self</span>.y, <span style="color: #51afef;">self</span>.z))
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__eq__</span>(<span style="color: #51afef;">self</span>, other):
      <span style="color: #51afef;">return</span> <span style="color: #c678dd;">tuple</span>(<span style="color: #51afef;">self</span> @ other.z) == <span style="color: #c678dd;">tuple</span>(other @ <span style="color: #51afef;">self</span>.z)
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__add__</span>(<span style="color: #51afef;">self</span>, other):
      <span style="color: #dcaeea;">px</span>,<span style="color: #dcaeea;">py</span>,<span style="color: #dcaeea;">pz</span> = <span style="color: #51afef;">self</span>
      <span style="color: #dcaeea;">qx</span>,<span style="color: #dcaeea;">qy</span>,<span style="color: #dcaeea;">qz</span> = other
      <span style="color: #51afef;">return</span> _pt((px*qx + (py*qz + pz*qy)*r) % N,
                (px*qy + py*qx + r*pz*qz) % N,
                (py*qy + px*qz + pz*qx) % N)
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__rmul__</span>(<span style="color: #51afef;">self</span>, n):
      <span style="color: #51afef;">return</span> <span style="color: #51afef;">self</span> * n
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__mul__</span>(<span style="color: #51afef;">self</span>, n):
      <span style="color: #51afef;">return</span> generic_pow(_pt.__add__, _pt(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">0</span>,<span style="color: #da8548; font-weight: bold;">0</span>), <span style="color: #51afef;">self</span>, n)
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">pell</span>(<span style="color: #51afef;">self</span>):
      <span style="color: #dcaeea;">x</span>,<span style="color: #dcaeea;">y</span>,<span style="color: #dcaeea;">z</span> = <span style="color: #51afef;">self</span>
      <span style="color: #51afef;">return</span> (x**<span style="color: #da8548; font-weight: bold;">3</span> + r*y**<span style="color: #da8548; font-weight: bold;">3</span> + r**<span style="color: #da8548; font-weight: bold;">2</span>*z**<span style="color: #da8548; font-weight: bold;">3</span> - <span style="color: #da8548; font-weight: bold;">3</span>*r*x*y*z) % N <span style="color: #5B6268;"># </span><span style="color: #5B6268;">== 1</span>
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__neg__</span>(<span style="color: #51afef;">self</span>):
      <span style="color: #51afef;">return</span> <span style="color: #a9a1e1;">NotImplemented</span>
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__matmul__</span>(<span style="color: #51afef;">self</span>, k):
      <span style="color: #51afef;">return</span> _pt(<span style="color: #51afef;">self</span>.x*k % N, <span style="color: #51afef;">self</span>.y*k % N, <span style="color: #51afef;">self</span>.z*k % N)
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">__repr__</span>(<span style="color: #51afef;">self</span>):
      <span style="color: #51afef;">if</span> <span style="color: #51afef;">self</span>.z == <span style="color: #da8548; font-weight: bold;">0</span>:
        <span style="color: #51afef;">if</span> <span style="color: #51afef;">self</span>.y == <span style="color: #da8548; font-weight: bold;">0</span>:
          <span style="color: #51afef;">return</span> <span style="color: #98be65;">'&lt;INFPOINT&gt;'</span>
        <span style="color: #51afef;">return</span> f<span style="color: #98be65;">'&lt;INFLINE {display(mod_inv(self.y, N)*self.x%N)}&gt;'</span>
      <span style="color: #dcaeea;">iz</span> = mod_inv(<span style="color: #51afef;">self</span>.z, N)
      <span style="color: #51afef;">return</span> f<span style="color: #98be65;">'&lt;{display(self.x*iz%N)} : {display(self.y*iz%N)}&gt;'</span>
  <span style="color: #51afef;">return</span> _pt
</pre>
</div>

<p>
With this information I was able to Google-the-paper much better. I spent a lot
of distracted time on an interesting paper called <i>A Group Law on the Projective
Plane with Applications in Public Key Cryptography</i> (2020), but it didn&rsquo;t go
anywhere toward a solution on this problem. But thinking about the special form
of the primes, and Pell&rsquo;s equation, I found <i>A novel RSA-like cryptosystem based
on a generalization of Redei rational functions</i> (2017) using cubic Pell. Yup,
there it was: everything.
</p>

<p>
Oh yeah, back there I was also trying to look for invariants to find the curve
in \(\mathbb{A}\) it was following, as I figured there would be one(?). I checked
all sorts of quadratic forms, some cubics, but never found it. No wonder,
because as the paper above the curve (cubic Pell) for this particular instance
turns out to be: \(x^3 + 2y^3 - 6xy + 3\). Jesus. (To be fair, that does mean it&rsquo;s
easy to find a point, namely <code>(1,1)</code>!)
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #dcaeea;">Pt</span> = mk_point(<span style="color: #da8548; font-weight: bold;">900397</span>, <span style="color: #da8548; font-weight: bold;">2</span>)
<span style="color: #dcaeea;">P</span> = Pt(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">1</span>)
<span style="color: #dcaeea;">Q</span> = P * <span style="color: #da8548; font-weight: bold;">1337</span>
<span style="color: #51afef;">assert</span> P.pell() == Q.pell()
</pre>
</div>

<p>
I mean it&rsquo;s cool&#x2026;but for nothing?
</p>

<p>
This paper also makes bold claims about how resistant it is to various classical
attacks et cetera, but then the citations immediately leads to another paper
(<i>Classical Attacks on a Variant of the RSA Cryptosystem</i>) with a rather dry
counter:
</p>

<blockquote>
<p>
They claimed that the classical small private attacks on RSA such as Wiener’s
continued fraction attack do not apply to their scheme. In this paper, we show
that, on the contrary, Wiener’s method as well as the small inverse problem
technique of Boneh and Durfee can be applied to attack their scheme.
</p>
</blockquote>

<p>
In the end it was super anticlimactic because the whole thing was a bit ugh. The
small inverse attack of course turns out to just be simple algebra. Duh. I might
have figured it out on my own, but due to all the rabbit holes above, all the
wishful thinking about how there was something cool about the group, the mental
fatigue set in and I didn&rsquo;t even bother looking at the plain small-\(d\) algebra.
</p>

<p>
I&rsquo;m still convinced the special form of the primes leads to a backdoor in this
cubic Pell group though. I mean, it has to, right? Like, why else? Why?
</p>

<p>
This task took the longest, like God knows how many hours, a day&rsquo;s amount of
&ldquo;work.&rdquo; But in the end didn&rsquo;t feel worth it.
</p>

<div class="org-src-container">
<pre class="src src-python">b<span style="color: #83898d;">'pbctf{I_love_to_read_crypto_papers_\x04+\x81\xf4-Th)Gj2m\x95\xc7\xd5\xe9\x8cZ\xaa\xcei\xc8u\xb3\xc3\x95\x9f\xdep\xae4\xcb\x10\xbdo\xd5\x83\x9c\xca\x1b3\xdee\xef\x89y\x07w"^\x1ez\x96\xb1\x1a\xd2\x9d\xc6\xfd\x1b\x8e\x1fz\x97\xba \x00\xf7l\xd4Yv\xb0\xd8\xb8\x0e\xf4\x93\xa4\x9fB\x97\xab\xd3eD\xa8\xc9\xa7x\x90r'</span>
b<span style="color: #83898d;">"and_implement_the_attacks_from_them}\xfb\x03\\\xdd\x9ch\x14\x89\x1d]\xfdf\xa8R\x81s\xf0\xbf\xfb\xa0\xe1\x90\xcfd\x82\xb4\xa5\x0b\x02\xc4r\x00wb|^\xd3\xf4\xb0N\xec\xf52\xe1\xb7\x9bF\x8dzW\xcbQ\xf3\xb7\xe7$\x81N\x1e\\\xfb\x1c:\xbb'\x11\xadQ.\x8e [,\xdee\xd7\x86\x95\x1ff\x18\x16u\xe4\x95jPcn{\x9f"</span>
</pre>
</div>

<p>
Ehh.
</p>

<p>
(Edit/addendum: OK, after spoiling myself and reading other writeups etc., it&rsquo;s
possible the small-\(d\) stuff was the intention. I have a theory: the problem
author probably/might have just come across the attack-paper above and thought
it would be cool in and by itself, some classics against something novel, but
didn&rsquo;t consider that the solvers would be so taken in by the cool group stuff,
i.e. the novelty, that then coming back down to <i>blah blah&#x2026;Coppersmith&#x2026;blah
blah</i> in the end would be a disappointment?)
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
by &ldquo;puzzles&rdquo; I mean problems that have a <i>natural</i> translation into
mathematics and reveal there a certain simplicity and elegance in generalized
form. It stands in marked contrast to &ldquo;riddles&rdquo;<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>, which tend to resist
mathematical patterns, and are usually dependent on culture, language, or
specific trivia.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I am pretty bad at escape-room CTFs where you hold up the message under a
full moon to reveal a bunch of points that turn out to align with certain zodiac
signs in the sky, and then after translating the zodiacs into numbers using the
provided plastic spy-codex, you get a number which turns out to be the Dewey
decimal index where you can find the book that was used for the book cipher.
(See <a href="https://masrt200.github.io/hacker-blog/hacktober-ctf">example</a>.) That kind of Sherlock Holmes stuff is completely orthogonal with
the kind of puzzles I enjoy.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Given appropriate adjustment of over-rated CTFs that feature stego and
guess-tasks.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I firmly believe the inventors of PHP ought to be retroactively
punished for having made the world a worse place. Every time I had to read a PHP
doc page and look at the comments by PHP users I could feel myself losing IQ
points as if breathing in neurotoxic mold.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
We&rsquo;re only a two-man team, so naturally we don&rsquo;t stand a chance for a
competitive placement, but it was a lot of fun with good, challenging tasks.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Maybe I&rsquo;m only critical because I&rsquo;m embarrassed it fooled me!
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
which is fine, but it could have been a sub-problem in another task for
example. One could also say it tries to teach you some math&#x2013;but it&rsquo;s the sort
of stuff with a trivial Sage/Google escape hatch. The trademark of low-effort
tasks that get ground up by the &ldquo;point mill&rdquo; into bland paste, rather than
offering any fun/engaging problem solving.
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Also: this was my first impression: <code>#!/usr/bin/env python2</code>. <code>:shudder:</code> This has nothing to do with the
task itself, but it always makes my heart sink and I lose a bit of faith in the
problem author and the world in general.
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
The question &ldquo;why <i>is</i> JavaScript?&rdquo; is ostensibly answered with &ldquo;because
fuck you, because we&rsquo;re engineers and we get the job done, that&rsquo;s why.&rdquo; But the
question &ldquo;why is JavaScript <i>the way it is</i>?&rdquo; can only be answered with a shrug
and an embarrassed silence. Indeed, why is any scatological piece of art the way
it is.
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
OK, actually the fact that it uses T-tables probably helps, as
high-weight input will likely lead to high-weight output from the lookups there?
I don&rsquo;t know, I&rsquo;ve never done any power-analysis before.
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11" role="doc-backlink">11</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I was assuming the wrong byte length of course, because it wasn&rsquo;t HMAC,
nor was it plain CRC(x), but it was salted. And I hadn&rsquo;t figured out the
byte-length independent approach.
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12" role="doc-backlink">12</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I suspect <code>Show your Patience and Intelligence I</code> is another one, but
since I only partially solved it, I couldn&rsquo;t really say outright. See also
<a href="https://github.com/BookGin/my-ctf-challenges/tree/master/balsn-ctf-2019/images-and-words">https://github.com/BookGin/my-ctf-challenges/tree/master/balsn-ctf-2019/images-and-words</a>
from last year&rsquo;s BalsnCTF, which&#x2013;don&rsquo;t get me wrong&#x2013;is a really cool and
mind-blowing task, but you need three fairly independent key insights to solve
it. Although I guess in web this kind of stuff is more like the standard way of
doing things?
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13" role="doc-backlink">13</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
because the domain knowledge required for the entire thing grows
linearly with unrelated sub-tasks added. This is another reason why I don&rsquo;t like
mixed challenges. Crypto behind web, misc behind rev, etc. It feels like a sort
of &ldquo;miserly&rdquo; way of forcing the solve count to stay low even though the subtasks
are themselves easy or unoriginal. Generalists and people with &ldquo;broad&rdquo;
CTF-knowledge are already greatly rewarded and have a (fair!) advantage over
more specialized noobs (like me), but this doubles down on that advantage on the
task level.
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14" role="doc-backlink">14</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Norwegian for &rsquo;field&rsquo;
</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15" role="doc-backlink">15</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I say I lucked out because my <code>sage</code> seems to hit a bug when I do
<code>A.multiplicative_order()</code> directly. It just hangs and churns CPU for over a
minute, so most likely I would have given up on this avenue. Who knows why
<code>sage</code> does what it does sometimes. <code>:its_a_mystery:</code>
</p></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16" role="doc-backlink">16</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
looking up on OEIS felt like cheating but it saved a couple of minutes.
It&rsquo;s clear in hindsight, as the list goes: A, B, BAAA, BAAABBB,
BAAABBBBAAABAAABAAA and so on.
</p></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17" role="doc-backlink">17</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
There&rsquo;s only two hard problems in computer science: naming things, cache
invalidation, and off-by-one errors. (Recycled Twitter joke.)
</p></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18" role="doc-backlink">18</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
for some definition of fun. I must admit I sort of enjoy data/numpy
massaging, especially when it&rsquo;s precise binary data (as opposed to analog data
where you spend most of the time on cleanup or noise filtering).
</p></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19" role="doc-backlink">19</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
&ldquo;True&rdquo; guessy challenges for me are more like OSINT riddles or web
challs where you have no data or feedback&#x2013;you simply have to &ldquo;get&rdquo; the core
idea, and it&rsquo;s a binary yes/no. &ldquo;Numpy massaging&rdquo; tasks become a sort-of subgame
where you play with combining arrays or matrices while trying to make them
&ldquo;fit,&rdquo; and there <i>is</i> some indication or feeling whether you&rsquo;re &ldquo;closer&rdquo; to a
solution or not, e.g. by seeing what patterns you&rsquo;re able to produce. <i>Xoared</i>
from BalCCon2k CTF was another example like this, where you do simple transforms
of some blob of data, seeking lower and lower entropy, and eventually it
suddenly becomes a readable image.
</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20" role="doc-backlink">20</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Besides, online CTFs are completely broken in terms of the &ldquo;competitive
element,&rdquo; since forming super-teams ad infinitum and rolling up with a 20-man
group is all fair play, given the right communication tools and politics. The
only &ldquo;competitive&rdquo; element that exists is between antisocial dissidents that
have refused to merge into super-teams (yet)?
</p></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21" role="doc-backlink">21</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
of which only <code>Steganography 2.0</code> was relevant for me anyway.
Tho regarding that task: a pickled 5GB numpy array? Bitch, please, does it
look like I&rsquo;m made of RAM?
</p></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22" role="doc-backlink">22</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
fun fact: Blum-Blum-Shub was the first &ldquo;strong&rdquo; RNGs I was
properly exposed to, through the excellent <code>calc</code> command-line
program.
</p></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23" role="doc-backlink">23</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
What I call exploratory mathematics, or experimental mathematics,
especially when involving classical number theory.
</p></div></div>


</div>
</div></div>
</body>
</html>
